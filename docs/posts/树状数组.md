---
title: 树状数组
date: 2022-07-27 15:23:48
tags:
- 数据结构笔记
categories:
- 模版
- 数据结构
- 树状数组
---


## 树状数组
树状数组是一个简化版的线段树，其利用二进制数的特性，解决区间查询（主要是区间和查询），以及单点修改操作问题。
### 性质
 ![树状数组概念](../../themes/butterfly/source/img/树状数组概念.png)
1. 树状数组的下标可以表示出其区间长度是多少。
   如 4 = 0100 lowbit是最低有效位表示的值, lowbit(4) = 4也就是说其表示的区间为[1,4]
   再比如 5 = 0101 lowbit(5) = 1也就是其表示的区间为[5,5]
   所以要求其的前缀和就要涉及到其前驱节点，那么修改某个点必然会影响到其他区间所以就要设计的后继节点的概念
2. 直接前驱 c[i] -> c[i - lowbit(i)]
3. 直接后继 c[i] -> c[i + lowbit(i)]
4. 查询前i个位置的前缀和，那么就要将所有的c[i]前驱节点都加起来
5. 要想修改第i个位置的数值，那么就需要讲所有c[i]后继节点都修改

### [AcWing 241. 楼兰图腾](https://www.acwing.com/problem/content/243/)
在完成了分配任务之后，西部 314 来到了楼兰古城的西部。
相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(V)，一个部落崇拜铁锹(∧)，他们分别用 V 和 ∧ 的形状来代表各自部落的图腾。
西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n 个点，经测量发现这 n 个点的水平位置和竖直位置是两两不同的。
西部 314 认为这幅壁画所包含的信息与这 n 个点的相对位置有关，因此不妨设坐标分别为 (1,y1),(2,y2),…,(n,yn)，其中 y1∼yn 是 1 到 n 的一个排列。
西部 314 打算研究这幅壁画中包含着多少个图腾。
如果三个点 (i,yi),(j,yj),(k,yk) 满足 1≤i<j<k≤n 且 yi>yj,yj<yk，则称这三个点构成`V`图腾;
如果三个点 (i,yi),(j,yj),(k,yk) 满足 1≤i<j<k≤n 且 yi<yj,yj>yk，则称这三个点构成 `∧` 图腾;
西部 314 想知道，这 n 个点中两个部落图腾的数目。
因此，你需要编写一个程序来求出 V 的个数和 ∧ 的个数。

输入格式
第一行一个数 n。
第二行是 n 个数，分别代表 y1，y2,…,yn。

输出格式
两个数，中间用空格隔开，依次为 V 的个数和 ∧ 的个数。

数据范围
对于所有数据，n≤200000，且输出答案不会超过 int64。
y1∼yn 是 1 到 n 的一个排列。

输入样例：
```
5
1 5 3 2 4
```
输出样例：
```
3 4
```

### 题解
我们可以讲几何问题转换成代数问题，比如`V` 也就是我们需要找到一组`(i,j,k)`, `i>=j`, `k >=j`这样的三元组,所以我们需要设置Greater[i],表示第i个位置前面和后面的有多少个数比我们当前第i个位置数值为a[i]的数要大，最后根据乘法原理来匹配（左边任何一个比j要大的树都可以的与右边任何一个比j要大的数匹配）左右两边的数相乘就好。

建立树状数组，我们树状数组内部记录的是某个数值在原数组出现的次数
比如add（y,1)表示数值为`y`在我们坐标轴为`y`的上面出现次数加一，边建树，边查询我们就可以知道在某个位置之前出现数值的次数的

### CODE
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 200010;

int n;
int Greater[N], lower[N];
int tr[N];
int a[N];

// 取最低有效位置（表示其区间能表示的长度）
int lowbit(int x)
{
    return x & -x;
}

// 在x位置上加上c
void add(int x, int c)
{
    for(int i = x;i <= n; i += lowbit(i)) tr[i] += c;
}

// 前1～x的前缀和
int sum(int x)
{
    int res = 0;
    for(int i = x; i; i -= lowbit(i))
        res += tr[i];
    return res;
}


int main()
{
    cin >> n;
    for(int i = 1; i <= n; i ++)
        scanf("%d",&a[i]);

    // Greater[i]表示的i的左右比a[i]要大的数的个数
    // 同理lower
    // 现在先计算数值为y的左边比他大（小）的数的个数
    for(int i = 1; i <= n; i ++)
    {
        int y = a[i];
        // sum(n) - sum(y) 表示数值在[y,n],我们原数组内出现的个数
        Greater[i] = sum(n) - sum(y); 
        lower[i] = sum(y-1);
        add(y,1);   // 将y这个数值加入的树状数组当中
    }

    ll res1 = 0, res2 = 0;
    memset(tr,0,sizeof tr);
    for(int i = n; i; i --)
    {
        int y = a[i];
        res1 += Greater[i] * ((ll)(sum(n) - sum(y)));
        res2 += lower[i] * (ll)sum(y-1);
        add(y,1);
    }

    printf("%lld %lld\n",res1, res2);
    return 0;
}
```