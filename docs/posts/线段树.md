---
title: 线段树
date: 2022-07-25 15:28:30
tags:
- 数据结构笔记
- 线段树
categories :
- 模版
- 数据结构
- 线段树
---

## 线段树
线段树主要是用来动态维护并且对区间进行操作的，因为题目可能要求边操作边进行查询。
对于线段树题目主要考验的是代码能力以及使用变量去维护我们需要查询的信息。所以应当多写多练代码。

下面三道题目有且仅涉及到了单点操作，区间查询
pushup子节点更新父亲节点
```C++
// 用子节点来更新父节点
void pushup(int u)
{
    tr[u].v = max(tr[u << 1].v, tr[u << 1 | 1].v);
}
```

modify单点操作
```C++
// x表示要在x之后加入一个数据v
void modify(int u, int x, int v) 
{
    // 根节点的就返回(根节点的就是我们要修改的那个单点)
    if(tr[u].l == x && tr[u].r == x)
    {
        tr[u].v = v;
    }
    else
    {
        // 不是根节点，那么这个节点就是父节点，那么继续递归找到根节点，然后用子节点来更新我们的父节点。
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);  // 操作完了区间就需要对区间维护的属性进行更新
    }
}
```

query区间查询
```C++
int query(int u, int l, int r)
{
    // 查询区间主要包含的了两种情况
    // 1. 当前区间完全包含在了我们要查询的区间当中也就是ql <= l <= r <= qr
    // 2. 当前区间与查询区间有交集 ql <= l <= qr <= r （不等式的等号不同事成立）
    // 因为递归是二叉树形式递归所以我们要讨论端点和中值之间的关系
    // 2.1 l <= mid, 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间右孩子区间
    // 2.2 r >= mid + 1 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间左孩子区间
    int mid = tr[u].l + tr[u].r >> 1;   // mid是当前我们要查询的节点u的中值
    // 当前区间被完全包含在我们要查询的区间当中
    if(l <= tr[u].l && tr[u].r <= r) return tr[u].v;
    // 有交集
    int v = -1; // 保存是孩子节点的最大值
    if(l <= mid) v = query(u << 1, l, r);    // 要注意这里接口是[l,r]而不是[l,mid],因为我们始终要查询的是[l,r]区间,而不是孩子节点的区间端点
    if(r > mid) v = max(v,query(u << 1 | 1, l, r));

    return v;
}
```

### [AcWing 1275. 最大数](https://www.acwing.com/problem/content/1277/)
给定一个正整数数列 a1,a2,…,an，每一个数都在 0∼p−1 之间。

可以对这列数进行两种操作：

添加操作：向序列后添加一个数，序列长度变成 n+1；
询问操作：询问这个序列中最后 L 个数中最大的数是多少。
程序运行的最开始，整数序列为空。

一共要对整数序列进行 m 次操作。

写一个程序，读入操作的序列，并输出询问操作的答案。

输入格式
第一行有两个正整数 m,p，意义如题目描述；

接下来 m 行，每一行表示一个操作。

如果该行的内容是 Q L，则表示这个操作是询问序列中最后 L 个数的最大数是多少；

如果是 A t，则表示向序列后面加一个数，加入的数是 (t+a) mod p。其中，t 是输入的参数，a 是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 a=0）。

第一个操作一定是添加操作。对于询问操作，L>0 且不超过当前序列的长度。

输出格式
对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 L 个数的最大数。

数据范围
1≤m≤2×105,
1≤p≤2×109,
0≤t<p
输入样例：
```
10 100
A 97
Q 1
Q 1
A 17
Q 2
A 63
Q 1
Q 1
Q 3
A 99
```
输出样例：
```
97
97
97
60
60
97
```
样例解释
最后的序列是 97,14,60,96。

### 题解
**板题** 
用一个变量维护我们需要查询的属性

### CODE
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 200010;

struct node
{
    int l, r; // 表示区间的左端点和右端点
    int v;  // 基本属性（本题是求的是最大值那我们就需要使用v表示区间的最大值来维护区间属性，有的属性并不能有单一的变量来维护则要多添加几个变脸来维护
    // node(){}
    // node(int l, int r):l(l),r(r),v(-1){}
}tr[N * 4]; // 线段树的节点个数开4倍

void build(int u, int l, int r)
{
    tr[u] = {l,r};  // 一定要把值先存起来，切忌不能放在return后面再保存值
    int mid = l + r >> 1;   // 线段树是一颗完全二叉树，其区间也划分的十分的均匀（正因为这种划分才使得所有的父节点一定有两个子节点）
    if(l == r) return;  // 根节点就要返回
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);   // 完全二叉树的属性 根节点从一开始编号，左孩子编号就是父节点编号的两倍，右孩子就是父节点的编号两倍加一
}

int query(int u, int l, int r)
{
    // 查询区间主要包含的了两种情况
    // 1. 当前区间完全包含在了我们要查询的区间当中也就是ql <= l <= r <= qr
    // 2. 当前区间与查询区间有交集 ql <= l <= qr <= r （不等式的等号不同事成立）
    // 因为递归是二叉树形式递归所以我们要讨论端点和中值之间的关系
    // 2.1 l <= mid, 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间右孩子区间
    // 2.2 r >= mid + 1 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间左孩子区间
    int mid = tr[u].l + tr[u].r >> 1;   // mid是当前我们要查询的节点u的中值
    // 当前区间被完全包含在我们要查询的区间当中
    if(l <= tr[u].l && tr[u].r <= r) return tr[u].v;
    // 有交集
    int v = -1; // 保存是孩子节点的最大值
    if(l <= mid) v = query(u << 1, l, r);    // 要注意这里接口是[l,r]而不是[l,mid],因为我们始终要查询的是[l,r]区间,而不是孩子节点的区间端点
    if(r > mid) v = max(v,query(u << 1 | 1, l, r));

    return v;
}

// 用子节点来更新父节点
void pushup(int u)
{
    tr[u].v = max(tr[u << 1].v, tr[u << 1 | 1].v);
}

// 本题是修改（增加）某个区间中的一个值来影响区间max属性，当根究还是单点操作，所以单点操作也就是把其包含这个点的所有区间都做一遍操作是logn的
// x表示要在x之后加入一个数据v
void modify(int u, int x, int v) 
{
    // 根节点的就返回(根节点的就是我们要修改的那个单点)
    if(tr[u].l == x && tr[u].r == x)
    {
        tr[u].v = v;
    }
    else
    {
        // 不是根节点，那么这个节点就是父节点，那么继续递归找到根节点，然后用子节点来更新我们的父节点。
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);  // 操作完了区间就需要对区间维护的属性进行更新
    }
}

int main()
{
    int n = 0, last = 0;    // n表示数据量/当前序列尾部的位置（因为每次都需要在序列尾部加入数据）, last记录的上个数据每次加上的数据 == (t + a) % p
    int m, p;
    cin >> m >> p;
    build(1,1,m);   // 由于有m个操作，最极限的情况下每个操作都是加一个数，那么我们的区间右端点的最大为m

    char op[2];
    int x;
    while(m --)
    {
        scanf("%s%d",op, &x);
        if(*op == 'Q')
        {
            last = query(1,n-x+1, n);
            printf("%d\n",last);
        }
        else
        {
            int v = ((ll)last + x ) % p;
            modify(1, n + 1, v);
            n ++;
        }
    }
    return 0;
}
```

### [AcWing 245. 你能回答这些问题吗](https://www.acwing.com/problem/content/246/)
给定长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：

1 x y，查询区间 [x,y] 中的最大连续子段和，即 maxx≤l≤r≤y{∑i=lrA[i]}。
2 x y，把 A[x] 改成 y。
对于每个查询指令，输出一个整数表示答案。

输入格式
第一行两个整数 N,M。

第二行 N 个整数 A[i]。

接下来 M 行每行 3 个整数 k,x,y，k=1 表示查询（此时如果 x>y，请交换 x,y），k=2 表示修改。

输出格式
对于每个查询指令输出一个整数表示答案。

每个答案占一行。

数据范围
N≤500000,M≤100000,
−1000≤A[i]≤1000
输入样例：
```
5 3
1 2 -3 4 5
1 2 3
2 2 -1
1 3 2
```
输出样例：
```
2
-1
```

### 题解
1. 题目操作二告诉本题是单点操作是不需要懒标记的
2. 如果使用子节点来更新父节点，也就是用什么变量来维护最大子段和

首先一定需要的保存区间的最大连续子段和tmax，但是单使用两个子区间的tmax来更新父区间tmax是远远不过的。因为父区间的tmax不单单是可能等于左孩子的tmax或者右孩子tmax，还有可能子段和是横跨左右两个区间的。所以还需要最大前缀和与最大的后缀和。但是问题又来了仅靠当前的变量足够更新我们所有的属性吗？？比如前缀和的更新问题。区间的前缀和 == max(left.lmax, right.lmax) ?? 显然不是，区间的前缀和是可以延伸到有区间上去的，所以 lmax = max(left.lmax, left.sum + right.lmax)，所以还需要增加一个变量区间的总和。
所以我们一个区间节点要保存 `sum` `lmax` `rmax` `tmax`四个变量来更新我们需要查询的`最大子段和`

### CODE
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 500010;

struct node
{
    int l,r;
    // 维护区间子段和最大
    int sum, lmax, rmax, tmax;  // sum区间和 lmax前缀和最大 rmax后缀和最大 tmax区间和最大
}tr[N * 4];

int w[N];   // 记录每个点的数值

void pushup(node &u, node &l, node &r)
{
    u.sum = l.sum + r.sum;
    u.lmax = max(l.lmax, l.sum + r.lmax);
    u.rmax = max(r.rmax, r.sum + l.rmax);
    u.tmax = max(max(l.tmax,r.tmax), l.rmax + r.lmax); 
}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    
    if(l == r) 
        tr[u] = {l, r, w[r], w[r], w[r], w[r]};
    else
    {
        tr[u] = {l,r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

node query(int u, int l, int r)
{
    if(l <= tr[u].l && tr[u].r <= r)
        return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        node res;
        if(r <= mid) return query(u << 1, l, r);
        if(l > mid) return query(u << 1 | 1, l, r);

        auto left = query(u << 1, l, r);
        auto right = query(u << 1 | 1, l, r);
        pushup(res, left, right);
        return res;
    }
}

void modify(int u, int x, int v)
{
    if(tr[u].l == x && tr[u].r == x)
        tr[u] = {x,x,v,v,v,v};
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) 
            modify(u << 1, x, v);
        if(x > mid)
            modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        scanf("%d",&w[i]);

    build(1, 1, n);
    int op , a, b;
    while(m --)
    {
        scanf("%d%d%d",&op,&a,&b);
        if(op == 1)
        {
            if(a > b) swap(a,b);
            node res = query(1,a,b);
            printf("%d\n",res.tmax);
        }
        else
        {
            modify(1, a, b);
        }
    }
    
    return 0;
}
```

### [AcWing 246. 区间最大公约数](https://www.acwing.com/problem/content/247/)
给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：

C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。
Q l r，表示询问 A[l],A[l+1],…,A[r] 的最大公约数(GCD)。
对于每个询问，输出一个整数表示答案。

输入格式
第一行两个整数 N,M。

第二行 N 个整数 A[i]。

接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。

输出格式
对于每个询问，输出一个整数表示答案。

每个答案占一行。

数据范围
N≤500000,M≤100000,
1≤A[i]≤1018,
|d|≤1018
输入样例：
```
5 5
1 3 5 7 9
Q 1 5
C 1 5 1
Q 1 5
C 3 3 6
Q 2 4
```
输出样例：
```
1
2
4
```

### 题解
操作一看似是一个区间操作问题但是如果使用差分数组的话，我们可以将其转化为单点操作

#### 一、将区间操作转换成了单点操作
原数组为 a1 a2 a3 a4 ... an
前缀和数组 为 s1 s2 s3 s4 ... sn
差分数组为 d1 d2 d3 d4 ... dn = s1， s2 - s1, s3 - s2, ... , sn - sn-1
sum[l,r] = dr + dr
假如要想在[l,r]区间加上一个d = dl + d, dr+1 - d
 
#### 二、gcd更相减损法
 gcd(a, b) = gcd(a, b - a)
 推广成为gcd(a1, a2, a3, ... , an) = gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)
 这样就可以与差分数组结合在一起

 证明更相减损法的正确性
 首先证明`gcd(a1, a2, a3, ... , an)` <= `gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)`
 `gcd(a1, a2, a3, ... , an)` == `d`, `d`是这个序列的最大公约数所以一定也是`a1` `a2` `a3`...的公约数，那么`d`同理也是`a2-a1` `a3 - a2` ...的公约数，所以知道左边序列的最大公约数是右边序列的任意一个公约数，所以证得`gcd(a1, a2, a3, ... , an)` <= `gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)`

 同理 `gcd(a1, a2, a3, ... , an)` >= `gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)`

差分数组
a数组是b数组的前缀和数组，b是a的差分数组
通过gcd更相减损法维护差分数组最后可以转换为
gcd[l,r] = gcd(a[l], a[l+1] - a[l], ... , a[r] - a[r-1]) = gcd(a[l], b[l+1], b[l+2], ... , b[r]) = gcd(a[l],gcd(b[l+1], ... , b[r])) = 由于线段树维护的是差分数组,a是前缀和数组，所以a[l]是我们1～l的sum = gcd(l.sum, gcd(b[l+1], ... , b[r]));
所以pushup操作是维护的`gcd(b[l+1], ... , b[r])`
最后我们要查询的区间最大gcd是通过`sum` + `gcd(b[l+1], ... , b[r])` 来维护
#### 三、维护区间属性
 1. 区间和sum
 2. 区间的最大公约数

### CODE

```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 500010;

struct node
{
    int l, r;
    ll sum, d;
}tr[N * 4];

ll a[N];

// 一般如果使用多变量维护区间属性重载两个pushup比较方便
void pushup(node &u, node &l, node &r)
{
    u.sum = l.sum + r.sum;
    u.d = gcd(l.d, r.d); 
}

void pushup(int u)
{
    pushup(tr[u], tr[u << 1], tr[u << 1 | 1]);
}

void build(int u, int l, int r)
{
    if(l == r)
    {
        ll b = a[r] - a[r-1];
        tr[u] = {l,r,b,b};  // 差分数组内部点值 a数组是b数组的前缀和数组，b是a的差分数组
    }
    else
    {
        tr[u].l = l, tr[u].r = r;   
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

node query(int u, int l, int r)
{
    if(l <= tr[u].l && tr[u].r <= r)
        return tr[u];
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if(r <= mid) return query(u << 1, l, r);
        if(l > mid) return query(u << 1 | 1, l, r);

        auto left = query(u << 1, l, r);
        auto right = query(u << 1 | 1, l , r);
        node res;
        pushup(res, left, right);
        return res;
    }
}

void modify(int u, int x, ll v)
{
    // 修改当点 a[l] + v, a[r + 1] - v
    if(tr[u].l == x && tr[u].r == x)
    {
        ll b = tr[u].sum + v;
        tr[u] = {x,x,b,b};
    }
    else
    {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) modify(u << 1, x, v);
        if(x > mid) modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        scanf("%lld",&a[i]);
    build(1,1,n);

    char op[2];
    int l, r;
    while(m --)
    {
        scanf("%s%d%d",op,&l,&r);
        if(*op == 'Q')
        {
            auto left = query(1,1,l);
            node right = {0,0,0,0};
            if(l + 1 <= r)
                right = query(1,l + 1, r);
            printf("%lld\n",abs(gcd(left.sum,right.d)));
        }
        else
        {
            ll v;
            scanf("%lld",&v);
            modify(1,l,v);
            if(r + 1 <= n) modify(1,r + 1, -v);
        }
    }
    return 0;
}
```


### 带有区间修改的（懒标记的线段树）
区间修改当然是可以依照我们前面的单点修改去操作，也就是一遍遍的遍历到根节点，然后用根节点去更新父亲节点。时间复杂度是O（nlogn）的
这样子时间复杂度甚至还比O（n）要大（比暴力更大），这显然是我们不能接受的。所以才会引入懒标记（延迟标记）来应付我们的查询。懒标记的思想可以类比到我们的区间查询。
 ![懒标记的解释](../../themes/butterfly/source/img/懒标记的解释.png)

### [AcWing 243.一个简单的整数问题2](https://www.acwing.com/problem/content/description/244/)

给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：

C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。
Q l r，表示询问数列中第 l∼r 个数的和。
对于每个询问，输出一个整数表示答案。

输入格式
第一行两个整数 N,M。

第二行 N 个整数 A[i]。

接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。

输出格式
对于每个询问，输出一个整数表示答案。

每个答案占一行。

数据范围
1≤N,M≤105,
|d|≤10000,
|A[i]|≤109
输入样例：
```
10 5
1 2 3 4 5 6 7 8 9 10
Q 4 4
Q 1 10
Q 2 4
C 3 6 3
Q 2 4
```
输出样例：
```
4
55
9
15
```

###  题解
虽然说区间加和问题可以用差分思想转换成单点操作但是我们也可以很暴力使用pushdown对区间进行操作

### CODE
```C++
#include <vector>
#include <cstring>
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <map>
#include<cmath>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 100010;

int n,m;
ll w[N];

struct node
{
    int l, r;
    ll sum, add;    // add是区间的懒标记，表示以u为根的树给其子节点都加上一个数值add（注意不给根节点加）
}tr[N * 4];

void pushup(int u)
{
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

// 用父节点更新子节点信息
void pushdown(int u)
{
    if(tr[u].add)
    {
        node &root = tr[u], &left = tr[u << 1], &right = tr[u << 1 | 1];
        left.sum += (left.r - left.l + 1) * root.add;
        left.add += root.add;
        right.sum += (right.r - right.l + 1) * root.add;
        right.add += root.add;
        root.add = 0;   // 下放之后一定要清空否则会重复累加
    }
}

void build(int u, int l, int r)
{
    if(l == r)
    {
        tr[u].l = l, tr[u].r = r, tr[u].sum = w[r], tr[u].add = 0;
    }
    else
    {
        tr[u].l = l, tr[u].r = r;  
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

ll query(int u, int l, int r)
{
    // 我们的懒标记是延迟标记是为了避免做无用功，所以在我们查询的操作的使用才会对其子节点的区间的懒标记进行更新
    // 每次从父节点到子节点的时候懒标记都下放，因为只要树要继续往下遍历的话那么说明子区间就需要被查询，所以我们懒标记下放
    if(l <= tr[u].l && tr[u].r <= r)
        return tr[u].sum;
    else
    {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(r <= mid) return query(u << 1, l, r);
        if(l > mid) return query(u << 1 | 1, l, r);

        ll res = query(u << 1, l, r) + query(u << 1 | 1, l , r);
        return res;
    }
}

void modify(int u, int l, int r, int d)
{
    if(l <= tr[u].l && tr[u].r <= r)
    {
        tr[u].sum += (tr[u].r - tr[u].l + 1) * d;
        tr[u].add += d;
    }
    else
    {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if(l <= mid) modify(u << 1, l, r,d);
        if(r > mid) modify(u << 1 | 1, l , r,d);
        pushup(u);
    }
}

int main()
{
    while(cin >> n >> m)
    {
        for(int i = 1; i <= n; i ++)
        scanf("%lld",&w[i]);

        build(1,1,n);

        char op[2];
        int l, r ,d;
        while(m --)
        {
            scanf("%s%d%d",op, &l, &r);
            if(*op == 'Q')
            {
                printf("%lld\n",query(1,l,r));
            }
            else
            {
                scanf("%d",&d);
                modify(1,l,r,d);
            }
        }
    }

    return 0;
}
```


### [AcWing 1277. 维护序列](https://www.acwing.com/problem/content/description/1279/)
老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

有长为 N 的数列，不妨设为 a1,a2,…,aN。

有如下三种操作形式：

把数列中的一段数全部乘一个值；
把数列中的一段数全部加一个值；
询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P 的值。
输入格式
第一行两个整数 N 和 P；

第二行含有 N 个非负整数，从左到右依次为 a1,a2,…,aN；

第三行有一个整数 M，表示操作总数；

从第四行开始每行描述一个操作，输入的操作有以下三种形式：

操作 1：1 t g c，表示把所有满足 t≤i≤g 的 ai 改为 ai×c；
操作 2：2 t g c，表示把所有满足 t≤i≤g 的 ai 改为 ai+c；
操作 3：3 t g，询问所有满足 t≤i≤g 的 ai 的和模 P 的值。
同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。

输出格式
对每个操作 3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。

数据范围
1≤N,M≤105,
1≤t≤g≤N,
0≤c,ai≤109,
1≤P≤109
输入样例：
```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7
```
输出样例：
```
2
35
8
```
样例解释
初始时数列为 {1,2,3,4,5,6,7}；
经过第 1 次操作后，数列为 {1,10,15,20,25,6,7}；
对第 2 次操作，和为 10+15+20=45，模 43 的结果是 2；
经过第 3 次操作后，数列为 {1,10,24,29,34,15,16}；
对第 4 次操作，和为 1+10+24=35，模 43 的结果是 35；
对第 5 次操作，和为 29+34+15+16=94，模 43 的结果是 8。

### 题解
**多懒标记问题**
本题对区间修改有两个操作，一个是乘法操作，另外一个是加法操作。所以需要维护两个懒标记。`add` `mul`

多懒标记更新，尽量要使得公式能统一一个形式
本题虽然是每次操作都是乘法或者加法，但是为了统一形式我们操作是无论加法和乘法都转换成`x * a + b` 的形式，`a = 1`时候为加法操作, `b = 0`为乘法操作，
如果多次对一个区间进行操作的话我们可以简化公式为
第一次对区间操作 `x * a + b`
第二次对区间操作`sum * c + d` <=> `(x * a + b) * c + d` <=> `x * a * c + b * c + d` <=>`x * (a * c) + (b * c + d)` 
所以知道原`add(b)`= `b * c + d`, 原`mul(a)` = `a * c`

如果是先加后乘的形式
`(x + a) * b`
第一次操作为`(x + a) * b`
第二次操作为`(sum + c) * d` <=> `((x + a) * b + c) * d` <=> `(x * b + a * b + c) * d` <=>`x * b * d + a * b * d + c * d` 这样子我们原数值sum都有一系列的系数了，很难更新我们当前的节点值

### CODE
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 100010;

struct node
{
    int l, r;
    int sum, add, mul;
}tr[N * 4];

int n,m, p;
int w[N];

// x * a + b + c = x * a + (b + c)
// (x * a + b) * c = x * a * c + b * c;
// 统一形式
// sum * c + d = (x * a + b) * c + d = x * (a * c) + (c*b + d)
int eval(int u, int a, int b)
{
    tr[u].sum = ((ll)tr[u].sum * a + b * (ll)(tr[u].r - tr[u].l + 1)) % p;
    tr[u].add = ((ll)a *  tr[u].add + b) % p;
    tr[u].mul = ((ll)tr[u].mul * a) % p;
}

void pushup(int u)
{
    tr[u].sum = ((ll)tr[u << 1]. sum + tr[u << 1 | 1].sum) % p;
}

void pushdown(int u)
{
    eval(u << 1, tr[u].mul, tr[u].add);
    eval(u << 1 | 1, tr[u].mul, tr[u].add);
    tr[u].add = 0;
    tr[u].mul = 1;
}

void build(int u ,int l, int r)
{
    if(l == r)
    {
        tr[u].l = l, tr[u].r = r;
        tr[u].add = 0, tr[u].mul = 1;
        tr[u].sum = w[r];
    }
    else
    {
        tr[u].l = l, tr[u].r = r;
        tr[u].add = 0, tr[u].mul = 1;
        int mid =  l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1 , r);
        pushup(u);
    }
}

void modify(int u, int l ,int r, int a, int b)  // x * a + b
{
    if(l <= tr[u].l && tr[u].r <= r)
    {
        eval(u, a, b);
    }
    else
    {
        pushdown(u);
        int mid = tr[u].r + tr[u].l >> 1;
        if(l <= mid) modify(u << 1, l, r, a, b);
        if(r > mid) modify(u << 1 | 1, l, r, a, b);
        pushup(u);
    }
}

int query(int u, int l, int r)
{
    if(l <= tr[u].l && tr[u].r <= r)
    {
        return tr[u].sum;
    }
    else
    {
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        int res = 0;
        if(l <= mid) res = query(u << 1, l, r);
        if(r > mid) res = ((ll)res + query(u << 1 | 1, l , r)) % p;
        return res;
    }
}

int main()
{
    cin >> n >> p;
    for(int i = 1; i <= n; i ++)
        scanf("%d",&w[i]);

    build(1,1,n);

    cin >> m;
    while(m --)
    {
        int op,l,r,a,b;
        scanf("%d",&op);
        if(op == 1)
        {
            scanf("%d%d%d",&l,&r,&a);
            b = 0;
            modify(1,l,r,a,b);
        }
        else if(op == 2)
        {
            scanf("%d%d%d",&l,&r,&b);
            a = 1;
            modify(1,l,r,a,b);
        }
        else
        {
            scanf("%d%d",&l,&r);
            printf("%d\n",query(1,l,r));
        }
    }
    return 0;
}
```
