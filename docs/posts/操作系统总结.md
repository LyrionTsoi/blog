---
title: 操作系统总结
date: 2023-07-17 15:46:55
tags:
---

**一些默认或者不常见的叫法**

- 程序计数器PC，也称为IP寄存器
- 可重入程序是指**该程序被某程序调用，但还未结束，又被另一个程序调用**。不属于临界资源，可以被共享使用
- 一个题中说某计算机配备三台打印机，一般认为三台打印机为同一类型（即用同一个驱动程序）。
- 一般默认缓冲区都是存放在内存当中（并且甚至是在内存的<span style='color:#CE3C05'>内核区</span>当中），不单独设立硬件。

# 第一章 计算机操作概述

## 操作系统的基本概念

### [概念](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254639221&cid=1285995536)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171549076.png)

### [功能](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254639221&cid=1285995536)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171551201.png)

可以看这一张图我们发现操作系统是位于硬件和软件之间的中介东西。所以其对下层硬件进行管理，对上层用户（软件）提供硬件的接口。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171551151.png)

**对计算机系统资源进行管理**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171554473.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171553978.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171554661.png)

**为上层提供硬件的接口**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171600264.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171555149.png)

**拓展计算机资源的扩充**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171559162.png)

### [特征](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254639221&cid=1285981447)

![=](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171601993.png)

**并发**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171600683.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171601501.png)

**共享**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171603130.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171603715.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171604093.png)

**虚拟**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171604626.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171605589.png)

**异步**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171604617.png)

## 操作系统的发展与分类

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171606175.png)

**手工操作阶段**

主要缺点：用户独占全集，人机速度矛盾导致的资源利用率极低

**批处理阶段**

*单道批处理系统*

主要优点：缓解了一定程度的人机速度矛盾， 资源利用率有所提升。

主要缺点：内存中**仅能有一道程序运行**，只有该程序运行结束之后才能调入下一道程序。 CPU有**大量的时间是在 空闲等待I/O完成**。资源 利用率依然很低。

*多道批处理系统*

主要优点：多道程序**并发**执行，共享计算机 资源。资源利用率大幅提升，CPU和其他资 源更能保持“忙碌”状态，系统吞吐量增大

主要缺点：用户响应时间长，<span style='color:red;background:背景颜色;font-size:文字大小;'>没有人机交互功能</span> （用户提交自己的作业之后就只能等待 计算机处理完成，中间不能控制自己的作业 执行。eg：无法调试程序/无法在程序运行过程中输入一些参数）

**分时操作系统**

主要优点：用户请求可以被即时响应，解决了<span style='color:red;background:背景颜色;font-size:文字大小;'>人机交互问题</span>。允许多个用户同时使用一台计算机，并且用 户对计算机的操作相互独立，感受不到别人的存在。

 主要缺点：<span style='color:red;background:背景颜色;font-size:文字大小;'>不能优先处理一些紧急任务</span>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/ 作业服务一个时间片，不区分任务的紧急性。

**实时操作系统**

主要优点：能够<span style='color:red;background:背景颜色;font-size:文字大小;'>优先响应一些紧急任务</span>，某些紧急任务不需时间片排队。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171645224.png)

**其他**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171645869.png)

**总结**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307171645762.png)



## 操作系统运行环境

### 处理器运行模式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191649894.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191649615.png)

*在后面指令还有被划分成更多的等级，零级指令，一级指令等*，但总的来说可以分为特权指令和非特权指令。

**注意：**指令并不是我们平时所说的`ls/mv`这些指令，指令都是二进制的，是机器指令。

非内核中的指令不代表不参与计算机资源的调度，比如后面我们学到的微内核os，将机制和策略分开。策略放在服务器上，机制放在微内核中.

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191709208.png)

**内核基本内容**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191700361.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191701063.png)

### 中断和异常的概念

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191711860.png)

**定义**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191711060.png)

**分类**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191713033.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191713383.png)

**中断和异常的处理过程**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191717216.png)

![完整的中断过程](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191714551.png)

<span style='color:#CE3C05'>具体的中断处理过程与系统调用的完整过程做对比学习（这部分特别容易记混）</span>

**中断处理过程**

1. 检查中断信号
2. 由硬件自动保存被中断程序的断点（即程序计数器PC和程序状态字寄存器PSW）
3. 硬件找到该中断信号对应的中断向量 ，**中断向量指明中断服务程序入口地址**
4. 开始执行中断服务程序，保存中断屏蔽字、保存各通用寄存器的值，并提供与中断信号对应的中断服务，中断服务程序属于操作系统内核
5. 通过保存的断点回到被打断的用户程序的第i条指令或者第i+1条指令继续执行，并且通过保存一些必要的寄存器的值恢复现场。

**系统调用处理过程**

中断处理和系统调用的之间的一些概念梳理。系统调用是应用程序需要使用到计算机资源所发出的请求，而中断处理机制往往是遇到一些意外需要处理才会进行的线程。但是中断处理依然是与系统调用有一定的联系的，可以看下面这张图。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211504764.png)

系统调用的过程因为要使用到陷入指令才可以使用到计算机资源，这一部分就是系统调佣中执行了中断程序的过程。所以如果说系统调用的具体过程，那么系统调用的过程一定是包括了中断处理程序的。

**具体的来说**

1. 进行参数的传递
2. 执行陷入指令
3. 检测到“内中断”后，由CPU负责保存断点（PC）和程序状态字（PSW），并将CPU模式改为内核态（这里就是中断指令执行的过程）
4. 执行操作系统内核的系统调用入口程序，该内核程序负责保存通用寄存器的内容，再调用某个特定的系统调用服务例程（注意这里就不同于中断处理程序）
5. 然后就是通过之前保存的寄存器内容恢复现场，然后返回发生中正常执行程序当中

**中断处理的一些注意点**

中断请求信号的发生是处于用户态发生的，所以这个指令的发生是非特权指令。通过中断信号告诉内核而处理要求中断是什么样的类型，我们的就会执行相应类型的中断或异常处理程序，这时候是处于内核态的所以这里是特权指令。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191717548.png)

### 系统调用

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191720516.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191719257.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191719417.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191720012.png)

**系统调用过程**（和中断程序执行过程做对比）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191723356.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191721447.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307191723956.png)

## [操作系统结构](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254650254&cid=1285984918)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211542941.png)

### 分层法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211544013.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211544122.png)

### 模块化

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211544163.png)

### 大内核

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211544056.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211544026.png)

微内核和大内核之间的对比![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211801195.png)

### 微内核

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211544069.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211544604.png)

机制与策略的划分

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211800275.png)

### 外核

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211544364.png)

## 操作系统引导

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211658090.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211701794.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211701106.png)

什么是BIOS?

BlOS（Basic Input Output System）从字义上称为“基本输出输入系统”，专门负责系统硬件各种参数设定，本质上是“程序”，也就是一组“代码”。

广义的引导程序包括了四个引导程序，如下

1.  ROM引导程序，<span style='color:#CE3C05'>注意一个点从硬件上来看bios和ROM是相等的</span>
2. 磁盘引导程序
3. 分区引导程序
4. 操作系统引导程序

狭义的引导程序指的是：操作系统引导程序

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211807354.png)

另一种执行过程的说法

①CPU加电，CS:IP指向FFFF0H;②执行JMP指令跳转到BIOS;

③登记BIOS中断程序入口地址；④硬件自检⑤进行操作系统引导；

CPU激活后，会从最顶端的地址FFFF0H获得第一条指令来执行，这个地址仅仅只有16字节，放不下一段程序，所以是一条JMP指令，以跳到更低地址去执行BIOS程序。BIOS程序在内存最开始的空间构建中断向量表和相应服务程序,在后续POST过程中要用到中断调用等功能，并且我们的IO设备在使用的过程中就是每一次的中断执行，如果不构建中断程序入口地址（ROM里面就已经保存了我们IO设备使用的驱动程序）我们是无法使用的。 然后进行通电自检POST （Power-on Self Test）以检测硬件是否有故障。完成POST后，BIOS需要在硬盘、光驱或软驱等存储设备搜寻操作系统内核的位置以启动操作系统 。

## 虚拟机

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211704792.png)

### 第一类虚拟机管理程序

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211704833.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211704814.png)

**注意这里并不是我们生活中的双系统这类的**，第一类虚拟机管理程序的多个os还是可以同时运行的

### 第二类虚拟机管理程序

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211704850.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211706686.png)

## 总结

1. 操作系统初始化的时候需要什么？

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211820695.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307211820458.png)

# 第二章 进程与线程

## 进程与线程

### 进程的概念与特征

**概念**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307241615799.png)

**注意：**

1. 进程是资源分配和调度的<span style='color:#CE3C05'>独立</span>单位，更加细化的来说：进程是资源分配的基本单位，和处理机调度的独立单位。
2. 区分进程靠的是进程`PCB`中的`PID`
3. 进程是暂时的，程序是永久的；进程是动态的，程序是静态的；进程至少由代码、数据和PCB 组成，程序仅需代码和数据即可；

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307241619011.png)

**进程特征**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307241620816.png)

**补充：**

进程还有封闭性。封闭性指的是一个形成一旦开始执行，其执行结果就只取决于它本身，不受外界影响。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307271604882.png)

### 进程的状态与转换

**状态**

三个基本状态（运行、就绪和阻塞）+两个状态

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261535051.png)

**转态转换**

![五状态转换模型](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261536734.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261535104.png)

**注意**

- 处理机在<span style='color:#CE3C05'>就绪队列存在进程</span>的时候，一定<span style='color:#CE3C05'>不会使处理机处于空闲的状态</span>。（拓展一点，即使就绪队列没有了进程，也会存在闲逛进程）
- 那么其实没有特定的指出存在闲逛进程的情况，<span style='color:#CE3C05'>处理机有且仅在所有进程都处于死锁的状态下</span>，全部进程都为阻塞态，<span style='color:#CE3C05'>处理机空闲即没有进程的执行</span>
- 正常的情况下（就绪队列有进程），一旦<span style='color:#CE3C05'>某个进程从处理机下来，就一定会引起进程的切换</span>（选择新的进程）
- 就绪队里的<span style='color:#CE3C05'>进程数上升</span>并不会使得处理器变得更加的高效。

**进程的组织**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261539170.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261539115.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261539155.png)

### 进程的组成

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261540335.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307271626467.png)

**处理机机相关信息可能包括了<span style='color:#CE3C05'>CPU状态</span>**

**补充：**

C语言编写的程序在使用内存时一般分为三个段，它们一般是正文段（即代码和赋值数据段）、 数据堆段和数据栈段。二进制代码和常量存放在正文段，动态分配的存储区在数据堆段，临时使用的变量在数据栈段。由此，我们可以确定全局赋值变量在正文段赋值数据段，未赋值的局部变 量和实参传递在栈段，动态内存分配在堆段，常量在正文段，进程的优先级只能在PCB内。

**进程控制块**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261541855.png)

**程序段**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261541847.png)

**数据段**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261541852.png)

### 进程控制

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261542748.png)

<span style='color:#CE3C05'>进程的控制与管理是通过原语来实现的</span>

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261543036.png)

#### 进程的创建

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261547233.png)

- 创建的完成是指的是从创建态到就绪态，即PCB被插入到就绪队列当中，注意内存不足的时候插入到阻塞队列不算是创建完成。
- 注意这里的引起进程创建的事件。

我们知道进程也是可以创建进程的，被创建的进程叫做子进程，创建者叫做父进程。

**父进程与子进程之间的关系**

父进程与子进程是在操作系统中进程创建和管理过程中的两种相关进程。

关系如下：

1. 创建关系：当一个进程（父进程）创建另一个新的进程（子进程）时，这两个进程就建立了一种创建关系。父进程通过调用系统调用（例如fork()或spawn()）来创建子进程。

2. 层次关系：在进程创建关系中，父进程可以有多个子进程，但每个子进程只有一个父进程。这样形成了一个进程树的层次结构，其中根是初始启动的进程，而其他进程则是由父进程衍生而来。

3. 资源继承：在大多数操作系统中，子进程从父进程继承一些资源，包括但不限于文件描述符、内存空间、打开的文件、环境变量等。子进程可以继续执行父进程的代码，也可以加载新的程序执行。

4. 进程通信：父进程和子进程之间可以通过进程间通信（IPC）机制进行交互和数据传输。常见的IPC方式包括管道、消息队列、共享内存、信号等。

5. 生命周期：父进程和子进程的生命周期并不总是相同的。通常情况下，子进程在创建后开始执行，而父进程可能继续执行其他任务或等待子进程完成。

总的来说，父进程和子进程之间的关系是一种衍生和继承关系，父进程创建子进程并共享一些资源，而子进程在父进程的基础上执行新的任务。这种进程之间的关系使得操作系统能够有效地进行任务管理和资源分配。

**进程的终止**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261547269.png)

#### 进程的阻塞与唤醒

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261547304.png)

#### 进程的切换

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261547330.png)

![进程控制总结](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261547355.png)

### 进程通信

#### 共享内存

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261551635.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261555096.png)

#### 消息传递

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261551243.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261551372.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261555978.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261555831.png)

#### 管道通信

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261552105.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261554036.png)

**注意**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261554031.png)

- 一般认为可以多个写进程一个读进程
- 管道是一种特殊的共享文件，是归文件系统进行管理的
- 全局变量是仅限于同一个进程进行共享

#### 拓展与总结

线程中的消息传递，虽然同一个进程中的线程与线程之间基本上可以做到无障碍相互访问，但是注意的是依然是有一部分私有的成分是不能够访问的。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307271644047.png)

### 线程和多线程模型

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261557710.png)

- 线程只由**相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成**，这样也可以说明线程被不同进程所调用，它们都属于同一个线程。

- 程序代码经过多次创建可对应不同进程，而同一个系统的进程（或线程）可以由系统调用的方法被不同的进程（或线程）多次使用。

- 适合线程运行的环境

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307271633842.png)

#### 线程与进程比较

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261557990.png)

- 线程可以<span style='color:#CE3C05'>独立的执行程序</span>，但是<span style='color:#CE3C05'>不可以脱离进程的执行</span>。其实比较好理解，因为线程处理机调度的基本单位，但是并不对线程进行资源的分配，所以线程是依赖于进程的存在的，没有进程的存在就不能使用计算机资源。
- 线程共享进程的地址空间和资源，即线程不具有独立的地址空间。

#### 线程属性

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261557009.png)

- 不同的线程

#### 线程状态与转换

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261600931.png)

- 在同一进程中，线程的切换不会引起进程的切换。当从一个进程中的线程切换到另一个进程 中的线程时，才会引起进程的切换

#### 线程的组织与控制

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261559595.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261601742.png)

#### 线程的实现方式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261559569.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261559613.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261604521.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261604621.png)

![主要线程库](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261559587.png)

#### 多线程模型

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261559643.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307261603155.png)

## 处理机调度

### 调度的概念

**概念**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291541096.png)

**调度的层次**

![三级调度](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291542321.png)

*高级调度（作业调度）*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291542119.png)

*中级调度（内存调度）*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291544428.png)

*低级调度（进程调度）*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291544155.png)

*三级调度的联系*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291544355.png)

### 调度的目标（对计算机的评价标准）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291543664.png)

### 调度的实现

**调度的程序**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291544340.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291544840.png)

**调度时机、切换与过程**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291545134.png)

**进程调度方式**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291546698.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291546559.png)

**闲逛进程**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291547999.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291548091.png)

**线程的调度**

![截屏2023-07-29 15.45.53](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291547009.png)

![截屏2023-07-29 15.47.00](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291547019.png)

### 典型的调度算法

#### FSFC

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291549910.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291549896.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291558427.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291558469.png)

#### SJF/SRNT

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291555024.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291558184.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291558217.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291558244.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291558275.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291558299.png)

#### 优先级调度算法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291556309.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291556779.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291600399.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291600453.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291600432.png)




#### 高响应比优先调度算法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291556209.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291559053.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291559020.png)


#### 时间片轮转调度算法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291555420.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291600844.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291600883.png)



#### 多级队列调度算法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291549926.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291555396.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291601629.png)





#### 多级反馈队列调度算法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291549958.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291601778.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291601810.png)



#### 总结

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307291550205.png)

## 同步与互斥

### 同步与互斥的基本概念

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011530951.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011531984.png)

**1. 临界资源**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011532759.png)

**注意**

1. 我们知道临界资源只能同时只有一个进程访问，注意这里很容易出现的一个错误是<span style='color:#CE3C05'>处于临界区的资源的进程是有可能被中断的</span>，这时候是<span style='color:#CE3C05'>允许其他进程抢占处理机资源</span>，但是<span style='color:#CE3C05'>不允许其他进程访问的临界区资源</span>。
2. 临界区指的是访问临界资源的<span style='color:#CE3C05'>代码程序</span>

**2.同步**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011532836.png)

**3.互斥**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011533094.png)

<span style='color:#CE3C05'>让权等待不是必须</span>，前三条是必须满足的条件。

### 实现临界区互斥的基本方法

**1.软件的实现方法**

*单标志法*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011535918.png)

*双标志法先检查*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011535283.png)



*双标志后检查*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011535941.png)



**Peterson's Algorithm。**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011536844.png)

![截屏2023-08-01 15.35.21](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011536664.png)



**2.硬件实现方法**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011537473.png)

*(1) 中断屏蔽方法*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011537166.png)

 *(2) 硬件指令方法*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011537676.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011537386.png)



### 互斥锁

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011538941.png)



### 信号量

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011538770.png)

- PV操作不是系统调用指令，应为PV操作中包含了关中断的和开中断指令，我们知道关中断和开中断都是特权指令，如果是系统调用的话一定是用户态需要系统服务所提出的系统调用请求。
- PV操作是一种低级进程同信原语

**1.整型信号量**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011540609.png)

**2. 记录型信号量**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011540725.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011540600.png)

**3.利用信号量实现同步**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011540648.png)

**注意：**

- 同步问题信号量的<span style='color:#CE3C05'>初始化不一定为0</span>（只有简单的前驱和后继问题才是初始化为0），经典例子为生产者和消费者问题。

**4.利用信号量实现进程互斥**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011540684.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011540634.png)

**5.利用信号量实现前驱关系**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011540445.png)



### 经典同步问题

**1.[生产者-消费者问题](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254656327&cid=1285985492)**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011546750.png)

**注意这里不要理解错，缓冲区没满只要缓冲区没有人访问的话消费者进程是可以进行消费的**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011548370.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011548509.png)

**可能会出现死锁问题**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011550964.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011550990.png)

**2.[多生产者-多消费者问题](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254656327&cid=1285997343)**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011551945.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011551815.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011552219.png)

**临界资源为1的时候会出现的特殊情况**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011552937.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011553122.png)

**总结**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011553666.png)

**3.[读者写者问题](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254656327&cid=1285995717)**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011557038.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011557374.png)

**实现**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011557074.png)

**总结**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011558517.png)



**3.[哲学家进餐问题](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254656327&cid=1285988960)**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011558449.png)

**发生死锁**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011559946.png)

**解决死锁的三种思路**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011600988.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011600047.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011600599.png)

**总结**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011601145.png)



**4.[吸烟者问题](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254656327&cid=1286010010)**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011554104.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011555177.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011555408.png)

**实现**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011556022.png)

注意上个面的finish变量是要求初始化的为0的，应为这是一个同步变量。

**总结**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308011556412.png)

## 死锁

### 死锁定义

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051440106.png)

<span style='color:#CE3C05'>死锁的发生一定伴随着两个及两个以上的进程。</span>

### 死锁产生的根本原因

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051440470.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051440445.png)

第一条的原因，换句话也可以说是<span style='color:#CE3C05'>资源不足</span>导致的，因为当资源如果足够充足是一定不存在资源不够用的情况的。

### 死锁产生的必要条件

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051446820.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051447387.png)

### 死锁的处理策略

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051447228.png)

#### [死锁预防](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254657096&cid=1285979730)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051447472.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051448480.png)

**注意这里破坏的每一种条件是使用的什么措施！！！**

拓展

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051502961.png)

互斥使用的资源实际上依然是同一时间甚至是同一时间段只能由一个进程所占有的，但是我们可以通过spooling技术从逻辑上实现出，破坏互斥使用的条件。

![截屏2023-08-05 15.04.20](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051504378.png)

#### [死锁避免](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254657096&cid=1285982888)

**银行家算法**（具体的看ppt）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051449436.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051450618.png)

注意

- 在使用银行家算法的时候，如果图方便的话，我们只找`Need < Available` 的情况，不进行分配直接回收，回收的是`Allocation`，而不是`MAX`。如果将`Available`分配出去（也就是减去`Need`）的话，则回收的是`MAX`。
- 死锁避免，<span style='color:#CE3C05'>不限制用户申请资源的顺序，限制的是资源分配到哪个进程的顺序。</span>
- 死锁避免是需要知道进程所需要的资源的总量的。



#### [死锁检测和解除](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254657096&cid=1285985497)

**资源分配图**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051452184.png)

- 死锁检测与解锁是<span style='color:#CE3C05'>不需要知道进程运行所需要的资源总量。</span>

**死锁定理**

死锁定理是用来<span style='color:#CE3C05'>检测死锁</span>，并不是用来解除死锁

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051452151.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051452769.png)

**死锁解除**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051453291.png)



# 第三章 内存管理

## 内存管理概念

### 内存管理的基本原理和要求

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111942841.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111942658.png)



#### 程序的链接

**从源程序到可执行程序的步骤**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111944100.png)



链接

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111945395.png)



#### 程序的装入

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111945692.png)

- 动态重定位是在作业的执行过程中进行的（动态重定位指的是在执行代码的时候讲逻辑地址转换成物理地址）
- 静态重定位，由于是一次性的装入作业，<span style='color:#CE3C05'>装入后位置不再改变</span>，所以一般使用在固定分区方式（可变分区在使用紧凑技术的时候存储位置会发生变化、页式、段式这些都是可能发生变化的）
- 静态重定位是连续存储，分配其要求的全部连续内存空间。

#### 逻辑地址与物理地址的区别

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111946841.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111946476.png)



#### 进程的内存映像

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111946530.png)



#### 内存保护

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111947127.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111947988.png)

- 内存保护是通过操作系统和硬件机构合作完成的



#### 内存共享

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111948845.png)



#### 内存分配与回收

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111948354.png)



### 覆盖与交换

**覆盖**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111949245.png)

- 可以看出来的覆盖技术一般应用在单一连续存储管理当中



**交换**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111949384.png)



### 连续分配管理方式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111950100.png)

- 分区存储管理的代价最小（实现最简单只需要连续的存储空间和一个上下限寄存器）



#### 单一连续分配

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111952354.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111952720.png)



#### 固定分区分配

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111953975.png)



![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111953293.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111953312.png)



#### [动态分区分配](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254664280&cid=1285987885)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111954180.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111954646.png)



#### [动态分区分配算法](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254664280&cid=1285985499)（与回收，可以结合ppt）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111955690.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111955771.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111958469.png)

- 合并分配区使用的是 <span style='color:#CE3C05'>紧凑技术</span>
- 合并空闲区使用的是 <span style='color:#CE3C05'>拼接技术</span>



### 基本分页存储管理

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308111959432.png)

- <span style='color:#CE3C05'>每一个进程都拥有一个页表，且进程的页表常驻内存。</span>在多个进程并发执行时，所有进程的页表大多数驻留在内存中，在系统中只设置一个页表寄存器（PTR）,它存放页表在内存中的始址和长度。平时，进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当调度到某进程时，才将这两个数据装入页表寄存器中。每个进程都有一个单独的逻辑地址，有一张属于自己的页表
- 分页存储是可以实现离散的存储，由于可以实现离散的存储并且不是每次都将所有也页调入到内存当中，所以页式存储方案也是的可以实现动态拓展的。（拓展来说这样也造成的不能使用静态重定位）

#### [分页存储的基本概念](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254664280&cid=1285998481)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112001689.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112001470.png)

- 系统提供给用户的物理地址空间为总空间大小减去页表或段表的长度。由于页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定。所以不能简单的认为分段(页)存储管理可以相对于分页（段）存储管理能分配更多的物理空间。



#### [基本地址变换机构](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254664280&cid=1285996542)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112002813.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112002517.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112010226.png)

- 我们都知道的页的初始地址都是的从主存中读取页表获得的，那么又一个问题那么页表的初始地址我们是如何获得呢？

  其实是通过页表寄存器获得的，这个寄存器存了页表的起始地址和长度。

- 我们知道逻辑地址转化成物理地址都是通过基址寄存器来进行转换的，对于基址寄存器来说是否需要给每个进程（数据）分配一个基址寄存器呢？

  其实不需要的，一方面是基于成本的控制，另一个方面是多道程序操作系统是不知道的一个时刻能有多少个进行需要执行的。

  所以整个机器只需要一个重定位寄存器。



#### 具有快表的地址变换机构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112003113.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112003962.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112011177.png)



#### [二级页表](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254664280&cid=1285977231)

**要注意二级页表访问内存块的过程进行结合理解**

就以二级页表为例，一级页表也称作为页表目录，由于一级页表存储二级页表的存储在内存块的信息，所以二级页表也是可以离散存储的，也就是说只有要求一级页表是连续的存储的。

一级页表有一个特性，一般只会占用一个页面。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112008451.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112008102.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112018793.png)



### 基本分段存储管理

#### 分段

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112019118.png)

- 分段存储管理有利于动态链接以及共享

- 分段一般是按照逻辑进行分段的，所以分段的进行阶段在用户编程的时候

  

#### 段表

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112020513.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112020718.png)



#### 地址变换机构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112020485.png)



#### 段的共享与保护

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112021559.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112021390.png)



### 段页式管理

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112021035.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308112021643.png)

-  每一个进程存在一张段表，每个段对应一张页表
-  用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间

### 总结

- 我们可以知道处理CPU对Cache和主存的数据之间交流是以字节进行的，其他的比如Cache和主存，主存和外存都是的以块为单位进行数据的交换的（分配同理)
- 仅接着上一条，如果机器是以字节进行编址话，访问主存，访问Cache这种存储的器依然是的以字节的进行的。注意这里是的访问而不是数据的交换
- 把逻辑地址转换成物理地址称作重定位



## 虚拟内存管理

### 虚拟内存的基本概念

**传统存储管理方式的特征**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142012869.png)



**局部性原理**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142016407.png)



**虚拟存储器的定义和特征**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142017655.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142017979.png)

- <span style='color:#CE3C05'>多次性</span>是虚拟存储器的最重要特征
- 虚拟存储器是逻辑上的一个存储器而非物理上的存储器的。<span style='color:#CE3C05'>即如果一个页面要上处理机运行的话就必须将页面存放到主存当中而非存放在虚拟内存当中。</span>
- 同理虚拟地址，对于虚拟地址，只要是要上处理机运行的，CPU访问该存储系统是发送的地址都是主存的物理地址



**虚拟内存技术的实现**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142017797.png)



### **请求分页管理方式**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142018063.png)



**页表机制**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142018174.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142018591.png)



**缺页中断机构**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142019751.png)

- 由于缺页中断是在指令执行的时候发生的，所以在处理完中断处理操作之后是需要返回的发生中断的那条指令（被中断指令的那一条）
- 如果进程的每一个页面都被访问到，有$m$个物理块供调度，进程包含了$n$个页面，缺页次数的不会少于$n$
- 如果进程的每一个页面都被访问到，有$m(m<n)$个物理块供调度，进程包含了$n$个页面，但是进程运行前预先调入了$n$个野蛮，缺页次数的不会少于$n-m$个页面



**地址变换机构**

*请求分页过程图*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142019703.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142020498.png)



### 页框分配

**驻留集**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142021563.png)



**内存分配策略**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142021229.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142024724.png)





**物理块调入算法**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142025126.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142025837.png)





**调入页面时机**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142025803.png)





**从何处调入页面**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142026125.png)





**如何调入页面**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142026368.png)

- 页表项中的合法位信息显示本页面是否在内存中，即决定了是否会发生页面故障。




### [页面置换算法](https://www.icourse163.org/learn/kaopei-1467209161?tid=1468336449#/learn/content?type=detail&id=1254652449&cid=1285982891)

#### 最佳置换算法（OPT)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142027970.png)





#### 先进先出页面置换算法（FIFO）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142028109.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142028836.png)





#### 最近最久未使用（LRU)置换算法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142028383.png)

- 导致LRU算法耗费高的原因是需要对所有的也进行排序（不是需要硬件的特殊支持）





#### 时钟（CLOCK)置换算法

*简单CLOCK置换算法*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142029810.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142029949.png)





*改进型CLOCK置换算法*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142030759.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142030920.png)



### 

### 抖动和工作集

**抖动**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142031813.png)

- 抖动的主要的原因可能是置换算法的不合理，进程数大多导致内存的不够用（如果单说内存太小不太准确）




**工作集**

要区分工作集和工作窗口

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142032069.png)





### 内存映射文件

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142035835.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142035316.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142035226.png)





### 虚拟存储器性能影响因素

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142036267.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142036255.png)



### 地址翻译（待补）





### 总结

虚拟内存的空间大小

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308142037592.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161853075.png)

<span style='color:#CE3C05'>虚拟地址是不受限，但是虚拟内存是受限的</span>





# 第四章 文件管理

## 文件系统基础

### 文件的基本概念

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181812145.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181812647.png)

- UNIX操作系统中，输入/输出设备会被视为<span style='color:#CE3C05'>特殊文件</span>(特殊文件只存在于主存中的内核区，外存不会保存特殊文件)



**文件结构**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181813630.png)







### 文件控制块和索引结点

#### 文件的属性

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181814344.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181814226.png)







#### 文件控制块(文件目录由有序的FCB组成)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181814834.png)

- 文件控制块也称为文件目录项
- 文件目录项是可以包含了文件的物理地址和文件的名字，但是不可能包含文件目录项的地址，因为没有任何意义，因为既然找到了文件目录项就是知道文件目录项的物理地址才可能成功找到。
- 像我们的UNIX操作系统，为了精简文件目录项，<span style='color:#CE3C05'>减少查找文件的I/O信息量</span>，就会将文件描述信息从中分离出去，形成索引结点。文件目录项由文件名和指向文件所对应的i节点指针构成
- 访问控制信息和有关于权限一些东西（口令类）可能会存放在FCB当中





#### 索引结点

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181815062.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181815689.png)

- 每一个文件对应一个索引节点（且<span style='color:#CE3C05'>无论文件多大也只会只有一个索引节点</span>，索引节点可以通过地址项的个数、间接寻址的级数来扩充我们指向的文件的范围）




### 文件的操作

#### 文件基本操作

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181817069.png)

- 创建文件夹的时候的就是为文件创建一个文件目录项

- 删除文件时候<span style='color:#CE3C05'>不需要删除文件的快捷方式</span>（软链接不回收）

- 

  





#### 文件的打开与关闭

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181818557.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181818064.png)

- 打开文件操作主要的工作时：把指定文件的目录项复制到内存指定的区域

- 文件的打开不一定只用“读”的方式打开文件的，也可以使用“写”的方式

- ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211656454.png)

  一个文件在系统打开文件表中只会存在<span style='color:#CE3C05'>唯一的一项</span>。每个用户进程在打开文件表当中，相同文件的<span style='color:#CE3C05'>对应的表项是不同</span>的，用户的打开文件表的表项是有该<span style='color:#CE3C05'>进程所特有</span>的东西的，比如读写指针，访问权限这类。






#### 文件保护

#### 访问类型

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181818668.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181819466.png)

- 用户在进入系统是必须进行注册，这是属于系统级的安全管理






#### 访问控制

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181819368.png)

- 对一个文件的访问，通常由 <span style='color:#CE3C05'>用户访问权限（口令或密码）</span>和<span style='color:#CE3C05'>文件属性</span>（有些文件是只读文件，即便是root用户都无法进行访问） 共同限制的
- 加密保护的其实不需要有系统实现的，但是访问控制机制必须由系统实现
- 加密保护机制安全性比访问控制会更加高的
- <span style='color:#CE3C05'>拓展一些概念</span>，存取控制矩阵也叫做访问控制矩阵，是类似于控制访问表的一个东西。控制访问表是基于存取控制矩阵加以优化的一个数据结构，优化取出冗余信息。







### 文件的逻辑结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181819689.png)

#### 无结构文件（txt文件）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181820058.png)









#### 有结构文件（记录式文件）

**顺序文件**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181821205.png)

- 定长记录



**索引文件**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181822333.png)

- 对索引文件存储的时候需要先查索引表
- 索引表当中保存的是<span style='color:#CE3C05'>逻辑地址</span>
- 逻辑结构层面上的索引表是为了让用户寻找到相应记录的<span style='color:#CE3C05'>逻辑地址</span>而存在的。（具体来说，如果我们想找到第三个记录，我们<span style='color:#CE3C05'>首先</span>是需要去找到<span style='color:#CE3C05'>索引文件中的索引表</span>，找到第三条记录的表项以此找到<span style='color:#CE3C05'>逻辑地址</span>。找到逻辑地址之后，假设我们是索引分配的方式的，那么我们需要去<span style='color:#CE3C05'>找的索引块</span>，<span style='color:#CE3C05'>通过逻辑地址，找到相应的表项</span>，最后<span style='color:#CE3C05'>转换成物理地址</span>。通过访存找到我们<span style='color:#CE3C05'>记录的数据</span>）






**索引顺序文件**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181822689.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181822824.png)

- 如果一组有100个表项，平均查找记录的次数 =  $\frac{(100 + 1) * 100}{2 * 100} = \frac{100 + 1}{2} = 50.5次 $






**直接文件或散列文件**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181823499.png)







### 文件物理结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181823946.png)

- 要注意，一个文件在同一个系统中、不同存储介质上复制的文件，不一定可以采取同一种物理结构。比如说我们的歌曲，在磁盘这种顺序存储介质当中，就只能采用连续存储，但是的在我们平时的SSD却可以采用离散存储。


#### 连续分配

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181823653.png)

- 在反复的增加和删除操作之后容易产生外部碎片




#### 链接分配

**隐式分配**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181825002.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181825019.png)

- 几个盘块组成一个组，使用链接成组技术，一条记录是不可跨越“块”存储的，即一条记录不能存放在两个块当中





**显式分配**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181825499.png)





#### **索引分配**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181825955.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181826588.png)





#### **混合索引分配**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181826492.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308181826508.png)





### 总结

- 提高文件的访问速度

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308191642070.png)

  注意延迟写也是的可以提高访问速度，本来要将已修改的文件存放回磁盘当中的，但是通过存放在缓冲区，达到一定数量才往回写磁盘的策略，如果在存放于缓冲区不久的时间用户还需要再次进行访问文件块，这个时候其实是不需要再次访问磁盘的，由于缓冲区保存了我们的文件块，所以只需要在缓冲区读取的即可

​	



## 目录

### 目录基本概念

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211625136.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211625504.png)







### 目录结构

#### 单级目录结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211630110.png)







#### 两级目录结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211631696.png)







#### 树形目录结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211631935.png)

- 设置当前目录，是为了加快文件检索速度（减少磁盘I/O）。

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211644267.png)

  每一次寻找到的文件夹，都会指向这个文件夹或者文件的存储地址，所以上面的这个例子读取到`4.1pptx`，一共是进行了四次的磁盘`I/O`的。换句话说找到的`4.1pptx`的地址进行3次磁盘`I/O`

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211649851.png)





#### 无环图目录

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211632488.png)





#### 目录的操作

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211632388.png)









### 文件共享

#### 基于索引节点的共享方式（硬链接）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211633228.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211633238.png)

- 注意这里的索引节点的如果说没有进程打开文件的话，这里的索引节点应为磁盘索引节点。但是的如果说是一个进程打开了文件，这里文件目录应该对应的是用户打开文件目录，索引节点为内存索引节点。





#### 利用符号链接实现文件共享（软链接）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211634241.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211634620.png)





#### 总结

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308211634363.png)







## 文件系统

### 文件系统结构

有两种版本

**国外教材**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231700906.png)

![截屏2023-08-23 17.01.02](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231701481.png)





**国内教材**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231702560.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231702618.png)





### 文件系统布局

#### 文件在磁盘中的结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231704090.png)

- 文件的索引结构存放在索引节点当做当中





#### 文件在内存的结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231718659.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231719501.png)





### 外存空闲空间管理

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231719235.png)

- 文件存储空间管理实际上就是对<span style='color:#CE3C05'>外存的空闲区</span>进行组织和管理
- FAT文件分配表也可以参与文件系统的管理（因为其记录了所有盘块的信息，即包含了块之间的联系，又包含了块是否有存储记录）







#### 空闲表法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231720325.png)





#### 空闲链表法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231720009.png)







#### 位示图法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231723235.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231723251.png)

- 注意，这里的每一位二进制表示的是<span style='color:#CE3C05'>磁盘块</span>是否空闲
- 位示图是仅是记录盘块是否被使用，而无法知道盘块之间的逻辑结构



位示图法相关的例题

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231729740.png)



#### 成组链接法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308302003005.png)





### 虚拟文件系统

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308302003914.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231724288.png)









### 分区和安装

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231724644.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308231725503.png)





# 第五章 输入/输出(I/O)管理

## I/O管理概念	

### I/O设备

**设备分类**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251659905.png)

![截屏2023-08-25 16.59.48](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251659877.png)

- 共享设备必须是可寻址的和可随机访问的设备（出自于5.1.6的第一题。这个概念有些模糊，这样的话鼠标就不是共享设备了）
- 虚拟设备是指把一个物理设备变换成多个对应的逻辑设备
- 字节多路通道用作连接大量的低速或中速I/O设备。



**I/O接口**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251700231.png)

- 为了便于上层软件的编制，设备控制器通常需要提供控制寄存器、状态寄存器（*控制和状态寄存器可能复用*）和<span style='color:#CE3C05'>控制命令</span>（不存在I/O地址寄存器；编程空间一般是由体系结构和操作系统共同决定的。）





**I/O端口**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251700391.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251701624.png)







### I/O控制方式

#### 程序直接控制方式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251701173.png)









#### 中断驱动方式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251701033.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251702974.png)









#### DMA方式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251702695.png)

- DMA其实就是在I/O设备和主存之间建立一套数据通路



其实使用不同I/O控制方式本质上就是对<span style='color:#CE3C05'>中断的频率进行优化</span>。从一个字发生一次中断请求到一个块发生一次中断请求。



### I/O软件层次结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251703158.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251703295.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301516781.png)

可以根据上图知道首先获得**键盘输入信息**的程序是<span style='color:#CE3C05'>中断处理程序</span>

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301517976.png)

- 及时性不是设备分配（设备分配是在设备独立性层需要做的事情）中应考虑的问题。

- 将系统中的每台设备按某种原则统一进行编号，这些编号作为区分硬件和识别设备的代

  号，该编号称为设备的<span style='color:#CE3C05'>绝对号</span>。

- 系统调用是操作系统提供给用户程序的通用接口，属于设备无关软件的功能，不会因为具体设备的不同而改变。而设备驱动程序负责执行操作系统发出的I/O命令，它因设备不同而不同。所以将系统调用参数翻译成设备操作命令的工作由<span style='color:#CE3C05'>设备无关的操作系统软件</span>完成







### 应用程序I/O接口

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251703256.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308251703724.png)















## 设备独立性软件

### 与设备无关的软件







### 高速缓存与缓冲区

**磁盘高速缓存(Disk Cache)**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301530797.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301530385.png)





**缓冲区（Buffer）**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301531193.png)

- 注意的是按分类来说单缓冲、双缓冲和循环缓冲都属于专用数据缓冲，即只能存在于两个进程的消息传递当中，不能使用在多并发进程系统。多并发进程系统要使用缓冲池

- 一般默认缓冲区都是存放在内存当中（并且甚至是在内存的<span style='color:#CE3C05'>内核区</span>当中），不单独设立硬件。

- 缓冲区是为了解决I/O花销过大的问题，所以如果I/O花销时间变得极小（远比CPU处理的小）的话，缓冲区就不会有任何意义

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301544352.png)

- <span style='color:#CE3C05'>缓冲区管理着重要考虑的问题是实现进程访问缓冲区的同步</span>。在缓冲机制中，无论是单缓冲、多缓冲还是缓冲池，由于缓冲区是一种临界资源，所以在使 用缓冲区时都有一个申请和释放（即互斥）的问题需要考虑。





#### 单缓冲

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301531493.png)







#### 双缓冲

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301532751.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301532566.png)







#### 循环缓冲

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301532144.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301532738.png)













#### 缓冲池

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301533659.png)



#### 高速缓存与缓冲区的对比

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301533498.png)









### 设备分配与回收

#### **设备分配概述**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301533095.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301535743.png)





#### 设备分配的数据结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301535868.png)





#### 设备分配的策略

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301536751.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301536967.png)







#### 设备分配的安全性

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301537620.png)













#### 逻辑设备名到物理设备名的映射

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301538391.png)







### SPOOLing技术（假脱机技术）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301538055.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301538840.png)

对于这个技术理解，就以共享打印机的例子说明。

如果我们需要打印一些文件，假设打印机是以块进行读取和打印的，所以每次打印机打印完一个块的数据的话，就会执行一次中断操作，这样会导致中断过于频繁。但是如果使用SPOOLing技术首先我们可以把全部打印的数据放在内存当中，然后把大量打印的数据存放在磁盘当中，后面打印的时候CPU就不会进行管理，并且缓冲区一定是比块要更大的单位，这样就减少了中断次数。









### 设备驱动程序接口



![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301539148.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308301539158.png)



