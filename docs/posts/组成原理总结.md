---
title: 组成原理总结
date: 2023-07-14 14:56:28
tags:
- 考研
- 核心课
- 408
categories:
- 考研
- 专业课
- 组成原理
---

一些别称或默认的原则

- 脏位，也称为修改位（一致维护位）

# 第一章 计算机系统概述

## 计算机系统层次结构

### 计算机硬件的基本组成

**冯洛伊曼机基本思想**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141512352.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141515726.png)

*特点*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141513557.png)

现代计算机结构

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141513750.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141514444.png)

### 计算机的功能部件

*框架*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141515167.png)

**存储器**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141516020.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141516208.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141517980.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141518678.png)

通常我们要取数据的话首先告诉`MAR`我们需要取的数据在存储体上的哪个地址，然后取出来的数据放到`MDR`上。

有些时候`MDR`还被集成在`CPU`当中

**运算器**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141519750.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141520649.png)

**控制器**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141520454.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141521100.png)

输入设备

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141522428.png)

输出设备

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141522568.png)

**计算机的工作过程**

下面是一段比较简单的具有加法和乘法的运算程序

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141523303.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141524263.png)

首先要执行程序一定需要取出来指令，所以每次都回存在取指令的过程。上面的`1~9`表示是取指令并且从主存当中取出来数`a`。

更多不再赘述，具体看[ppt](https://www.icourse163.org/learn/kaopei-1467188162?tid=1468338443#/learn/content?type=detail&id=1254404242&cid=1285644592)。



# 第二章 数据的表示和运算

## 数制与编码

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201639167.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201639121.png)

### 不同进制数之间的相互转换

**书写单位：**

- 二进制：B
- 八进制：$(\ \ )_8$
- 十六进制：$0x 1234$ 或者是 1234H
- 十进制：D

**任意进制转换成十进制**

只要每一位数值乘上相应的位权即可。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201641007.png)

<span style='color:#CE3C05'>二进制转换成八进制与十六进制</span>

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201641532.png)

**注意的是八进制是三位一组，十六进制的是四位一组。**

**十进制转换到任意进制**

*整数部分* （除进制权重）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201645514.png)

*注意*：这里先得到是低位，然后才是高位

*小数部分*（乘进制权重）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201647866.png)

不一定能用二进制数来表示出来小数，可能存在精度丢失

*注意：*这里想得到的是小数部分的高位

先得到是高位还是低位都是都可以从进制数的本质上去理解。

<span style='color:#CE3C05'>技巧</span>

对于一般我来说整数部分一般都是可以使用拼凑法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201651503.png)

### 定点数的编码表示

<span style='color:#CE3C05'>注意一个易忘的点，就是无论是原码、反码、补码还是移码都是表示有符号数的</span>

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201656315.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201652124.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201653704.png)

**原码**

表示范围：原点对称

有两个0（正负零）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201658819.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201658537.png)

**反码**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201659362.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201659724.png)

*反码转换原码：*各位取反

*反码转换成补码：*加一

反码和原码拥有相同的取值范围和拥有着正负零。

**补码**

***转换技巧***

补码转换成原码技巧：（主要第二条，并且是<span style='color:#CE3C05'>双向</span>转换都是可以的）

第一条易错的是 <span style='color:#CE3C05'>并不是全部位都取反，而是数值为取反然后加一</span>

要与$[x]_补$转换成 $[-x]_补$做区别，这里的转换是<span style='color:#CE3C05'>全部位</span>都取反

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307201530457.png)

$[x]_补$转换成 $[-x]_补$

所有位取反然后末位加一

*用处：* 可以比较方便进行减法运算

**移码**

补码的符号位取反

方便用来比较整数的大小

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231553639.png)

#### 原码、反码、补码、移码的总结

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231555316.png)

**带符号数表示**

四种编码当中带符号数有两种表示

下面以原码为例

1. 一位符号位， 0表示为正，1表示为负
2. 两位符号位，经常用来判断是否有溢出。<span style='color:#CE3C05'>最高位永远表示真正的符号。</span>这里需要做概念的区分。最高位表示的是理想位，次高位表示的实际位。但是实际位不一定是正确的，如$[01.1101]_原$，虽然次高位（实际位）表示的是1，但是最高位是0，这时候这个数发生的溢出，且<span style='color:#CE3C05'>这个数是为正</span>的，<span style='color:#CE3C05'>符号永远取决于最高位。</span>

## [运算方法和运算电路](https://zhuanlan.zhihu.com/p/554546968)

下面全部引自[知乎](https://zhuanlan.zhihu.com/p/554546968)并做一些修改和添加

### 一、无符号整数的表示和运算

Ⅰ、无符号整数的加法：从最低位开始，按位相加，并往更高位进位。

Ⅱ、”被减数“不变，”减数“**全部按位取反**，末位+1，**减法变加法。**

### 二、带符号整数的表示和运算

带符号的整数表示：原码、补码、反码

※带符号的整数运算可以用原码吗？

用原码的话符号位不能参与运算，需要设计复杂的硬件电路才能处理，贵。

这时候就可以利用补码来进行带符号的整数运算。

①涉及原码和补码的转化。

正数：原码->补码，不变

负数：原码->补码，除符号位外，各位取反，末位+1

#### Ⅰ、补码的加法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221803508.webp)

从最低位开始，然后按位相加，并往高位进位。算出来的结果，转回原码，就可以得到正值。

补充：补码->原码：类似，除符号位外，各位取反，末位+1

#### Ⅱ、补码的减法

※加法电路造价便宜，减法电路造价昂贵，若将减法变为加法，更加economize。

- 那我们知道了”减数“的补码，那如何求得”减数“负值的补码呢？

补码**全部位**取反，末位+1（易错这里是全部位取反，而带符号位的负数，是除符号位外，各位取反）

其实啊，这里的运算的逻辑结构和无符号的减法运算是一样的，通用一套电路，省钱！

#### 溢出判断

**这里是补码的加法器**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307281636853.png)

$C_n$表示的是符号位的进位， $C_{n-1}$表示的是最高数值位的进位。可以知道如果<span style='color:#CE3C05'>有且仅有一个进位，表示溢出</span>。如果<span style='color:#CE3C05'>符号位和数值位同时进位，则没有溢出。</span>

### 三、原码、反码和补码的特性对比

| 8bit       | 合法的表示范围 | 最大的数 | 最小的数 | 真值0的表示                                                  |
| ---------- | -------------- | -------- | -------- | ------------------------------------------------------------ |
| 带符号原码 | -127~127       | 127      | -127     | +0=00000000 -0=10000000                                      |
| 带符号反码 | -127~127       | 127      | -127     | +0=00000000 -0=11111111                                      |
| 带符号补码 | -128~127       | 127      | -128     | <span style='color:#CE3C05'>-/+0=00000000 只有这一种,10000000表示的最小值-128</span> |
| 无符号整数 | 0~255          | 255      | 0        | 00000000                                                     |
| 带符号移码 | -128~127       | 127      | -128     | 0=10000000 只有这一种                                        |

原码和反码的合法表示范围完全相同，而且都有两种表示真值0的方法。

补码的合法表示范围多一个负数，原因就是只有一种0的表示方法，因为-0的补码就是00000000

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221803658.webp)

### 四、移码，定点小数

移码：在补码的基础上<span style='color:#CE3C05'>符号位取反</span>。且移码只能表示整数。表示范围和补码相同。

移码的作用：*移码的作用就是方便计算机<span style='color:#CE3C05'>比较两个数数值的大小</span>。*

定点小数的编码表示：原码、反码、补码。

运算规则和整数的运算规则一模一样。

### 五、电路的基本原理和加法器设计

Ⅰ、补码/无符号整数加减法运算器

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221803928.webp)

减法运算过程：

①首先Sub信号置为1；

②多路选择器的值为1，Y（减数）经过非门，都取反；

③cin来自低位加1；

Ⅱ、标志位生成

①进位标志CF (Carry Flag)只对无符号运算有意义
当运算结果的<span style='color:#CE3C05'>最高有效位有进位（加法）或借位（减法）时</span>，进位标志置1，

即CF = 1；否则CF= 0。

49H + 6DH＝B6H，　没有进位：CF = 0

BBH + 6AH＝（1）25H，有进位：CF = 1

②零标志ZF (Zero Flag)
若运算结果为0，则ZF = 1；否则ZF = 0

49H + 6DH＝B6H，结果不是零：ZF = 0

75H + 8BH＝（1）00H，结果是零：ZF = 1

③符号标志SF (Sign Flag)只对有符号运算有意义
运算结果最高位为1，则SF = 1；否则SF = 0

49H + 6DH＝B6H=10110110B，SF=1

④溢出标志OF (Overflow Flag)只对有符号运算有意义
若算术运算的结果有溢出，则OF＝1；否则 OF＝0

49H + 6DH ＝B6H，产生溢出：OF = 1

75H + 8BH ＝（1）26H，没有溢出：OF = 0

<span style='color:#CE3C05'>进位CF和溢出OF位有什么区别呢？</span>

进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确，对有符号位加减法无意义。

溢出标志表示有符号数运算结果是否超出范围，运算结果已经不正确，对无符号加减无意义。

溢出的判断判断运算结果是否溢出有一个简单的规则：

只有当两个<span style='color:#CE3C05'>相同符号数相加（包括不同符号数相减）</span>，而运算结果的符号与原数据符号相反时，产生溢出；因为，此时的运算结果显然不正确其他情况下，则不会产生溢出

1.当两个符号相同的数相加，结果的符号与之相反，则OF=1,否则OF=0.

2.当两个符号不同的数相减，结果的符号与减数相同，则OF=1,否则OF=0.

### 六、定点数的移位运算

移位运算，左移移出的是有效位的话，就表示<span style='color:#CE3C05'>溢出</span>，右移溢出的是有效位的话表示<span style='color:#CE3C05'>丢失精度</span>

#### 算术移位

- 左移1位相当于×2，右移1位相当于÷2
- 原码：符号位不参与移位。左移，右移都补0
- 反码：符号位不参与移位。**若反码是负数补1；若反码是正数补0**
- 补码：符号位不参与移位。**若补码是负数左移低位补0，右移高位补1；若补码是正数，左移右移都补0**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307251452008.png)

#### 逻辑移位

可以看做无符号数的移位运算

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231528007.png)



#### 循环移位

这里是<span style='color:#CE3C05'>带进位位</span>的

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231529055.png)

注意这里只是最高位移到CF中，同时<span style='color:#CE3C05'>最高位又移动到最低位当中，注意不是CF移到最低位当中。</span>

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231529264.png)



### 七、原码补码的乘法除法运算

#### Ⅰ、原码的一位乘法

符号位通过异或确定；数值部分通过被乘数和乘数绝对值的n轮加法、移位完成，根据当前乘数中参与运算的位确定（ACC）加什么。若当运算位=1，则（ACC）+[|x|],若为0，则(ACC)+1。每轮加法完成后，ACC,MQ的内容统一算术右移。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221803151.webp)

先ACC初始化。x置于通用寄存器中，y置于MQ。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307252030170.JPG)

注意这里高两位或高一位来说其实都不能表示为符号位，上面对高位做出了解释，并且说明了这里的右移其实是<span style='color:#CE3C05'>逻辑右移</span>，但是这里的高一位（单符号）或高两位（双符号表示）都是参与了运算的。

#### Ⅱ、补码的一位乘法

原码一位乘法和补码一位乘法的不同点

| 原码一位乘法                      | 补码一位乘法                                 |
| --------------------------------- | -------------------------------------------- |
| 进行n轮的加法、移位               | 进行n轮加法，移位，最后再多来一次加法        |
| 每次加法相加，只有两种情况+0或加x | 每次加法加有三种情况，0或+x或+[-x]           |
| 每次移位都是逻辑右移，补1         | 每次都是补码的右移，正数右移补0，负数右移补1 |
| 符号位不参与运算                  | 符号位参与运算                               |

- 会添加一位辅助位
- 辅助位-MQ中“最低位”=1时，(ACC)+[X)]补
- 辅助位-MQ中“最低位”=0时，(ACC)+0
- 辅助位-MQ中“最低位”=-1时，(ACC)+[-X]补

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221816320.webp)

实现的细节问题：

- 可以知道N位数值位两位补码相乘（一位符号位），最后的乘积为 $2N+1$。很容易出现的一个错是认为辅助位会影响到最后的乘积位数，其实并不会的。
- n位二进制数（数值位+符号位）会进行n次加法，换一个说法n位数值位（1位符号位）会进行n+1次加法
- n位数值位会有n次移位运算j

#### III、原码除法运算

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221819389.png)

我们可以通过这一张图中的MQ知道，最终除法的精读取决于MQ的位数，往往MQ的位数就等于机器字长。

**恢复余数法**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231521843.png)

**加减交替法**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231522670.png)

**⚠️注意**

1. 由于我们使用算法是定点数的除法运算，所以这里是<span style='color:#CE3C05'>不能处理整数类型</span>，即<span style='color:#CE3C05'>被除数一定要小于除数</span>。那么如何判断被除数小于除数的呢？其实很简单，无论是恢复余数法还是加减交替法，如果<span style='color:#CE3C05'>第一步上商为1最后得出来的是一个正数那么一定是出现被除数大于除数的情况。</span>
2. 运算上的细节
   - 无论对于恢复余数还是加减交替来说，所有数都是<span style='color:#CE3C05'>取的是绝对值，补码的负数也是先取的绝对值然后再取负数的。</span>**要特别与补码的除法这里做出区别来，补码的除法是不进行加绝对值处理的**
   - 加减交替法，<span style='color:#CE3C05'>最后一步有可能是要使用恢复余数的情况</span>，其他不会出现恢复余数的情况
   - 加减交替法可能出现加/减 $n + 2$次的情况，这是可能最后一次上商为1，出现余数为负数的情况，要进行恢复余数的操作。注意<span style='color:#CE3C05'>相对应的补码的除法操作</span>，最后是恒上商为1，<span style='color:#CE3C05'>不会出现恢复余数</span>的操作。
   - 对于<span style='color:#CE3C05'>原码的除法运算</span>中的移位运算是 <span style='color:#CE3C05'>算术左移</span>，对于<span style='color:#CE3C05'>补码的除法运算</span>中的移位运算来说是<span style='color:#CE3C05'>逻辑左移</span>

**[恢复余数法中机器实际实现](https://www.icourse163.org/learn/kaopei-1467188162?tid=1468338443#/learn/content?type=detail&id=1254575031&cid=1285928071)**

#### IV. 补码除法运算

和原码除法运算中的加减交替法非常相似

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231640518.png)

第一步：<span style='color:#CE3C05'>被除数与除数的符号判断</span>，决定第一步是加上除数还是减去除数补码

接下里就是比较<span style='color:#CE3C05'>余数和除数之间的符号之间的关系</span>

注意这里的左移是<span style='color:#CE3C05'>逻辑左移</span>，即<span style='color:#CE3C05'>符号位要同时进行移位</span>运算

#### V.除法总结

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307231641426.png)

原码： 符号位运算 + 绝对值运算

补码： 符号位参与运算

原码的恢复余数算法和补码的除法运算左移都是<span style='color:#CE3C05'>逻辑左移</span>

原码的加减交替法是<span style='color:#CE3C05'>算术左移</span>

### 八、双符号位表示

双符号位的引入很好的表示符号进行运算之后是否发生了溢出现象。

双符号位要注意几点

1. 最高位符号位表示我们真正的的符号位
2. 最高位和次高位符号位不同，表示发生溢出
3. 双符号位具有记录错误的功能，比如移码运算的，移码一位时候发生溢出，之前有效位就会出现在次高位，如原码00 11111111 左移一位， 01 11111110，从双符号位的特性上来看我们很容易看出来发生了溢出现象，并且我们可以根据次高位的状态进行恢复原状态。

### 总结

1. 乘法如何判断溢出

   - n位乘n位 若用2n位保存则不会溢出
   - n位乘n位，用2n位保存中间结果，最后截n位作为最终成绩可能会溢出
   - 手算溢出进需要判断两个乘积结果是否超出了n位的表示范围
   - 机器判断溢出：
     - 有符号：前n+1位全0或全1，不溢出
     - 无符号：前n位全0，不溢出

2. 在题目讲的<span style='color:#CE3C05'>二进制最高位</span>一般都是指的是<span style='color:#CE3C05'>数值的最高位</span>

3. 移位运算<span style='color:#CE3C05'>符号位不参与运算</span>

4. 补码左移什么时候会发生溢出？

   一个二进制为 $X_0X_1X_2...X_n,X_0$是符号位，$X_1$是最高的数值位。可以从双符号位进行理解，现在将二进制拓展成双符号位 $X_0X_0,X_1X_2...X_n$，当左移就会变$X_0X_1,X_2...X_nX_{n+1}$，根据双符号位的判断我们知道 $X_0X_1$异号就一定是发生溢出。

5. 原码的乘除运算<span style='color:#CE3C05'>符号位都是单独处理</span>， 补码的乘除运算都是参与到运算当中的。

## C语言类型转换和数据存储排列

- C语言中定点整数是用”补码“存储的。
- 无符号数转为有符号数：不改变数据内容，改变解释方式。
- 长整数变为短整数：高位截断，保留低位。
- 短整数变长整数：若为有符号数，在符号位和数值位添1，若为无符号，直接在高位添0。
- 大小端模式：大端方式便于人类阅读；小端方式便于机器处理，因为机器最先读入的就是最应被处理的数据。
- 大端方式按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面；小端方式按从最低有效字节到最高有效字节的顺序存储数据 ，即最低有效字节存放在前面。

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201524732.png)

- 边界对齐：其实地址能被自身数据长度整除则叫做边界对齐。假设存储字长为32位，则1个字=32bit,半字=16bit。每次访存只能读/写1个字。若采用边界对齐的方式，则访问一个字/半字都需要一次访存，虽然会造成一点点的空间浪费。采用不对齐的方式，对空间利用率高，但是可能会涉及到两次访存时间大大增加。

**补充浮点数的强制类型转换**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311547595.png)

<span style='color:#CE3C05'>注意</span>上面的一个点，我们知道在`IEEE 754`标准中`double`是表示是`11`位阶码，`53`位有效尾数，如果是`64`位的`long`转换成`64`位的`double`一定是会损失精度的（$64 \to 53$),所以上面的说的$long \to double$ 不损失是处于`32`位机器当中



### 总结

**各种生成信号的总结**



## 浮点数的表示与运算

### 浮点数的表示

表示格式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538864.png)

注意书上还有另外一种格式(只是数符的摆放的位置不同)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311541739.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538891.png)

**浮点数的表示范围**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311542483.png)

**浮点数的规格化**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538878.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311543403.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311543815.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308021612245.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538826.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538843.png)

### IEEE 754

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538797.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538638.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538121.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538501.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311544270.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311544249.png)

**定点数与浮点数的之间的区别**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311544068.png)

### 浮点数的加减运算

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538522.png)

**舍入问题**

可以分为两种舍入方式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307311538550.png)



# 第三章 存储系统

## 存储器概述

### 存储器的分类

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308021541212.png)

**补充一些存储器**

*相联存储器*

可以按照<span style='color:#CE3C05'>内容</span>进行访问的存储器

是按照<span style='color:#CE3C05'>内容指定方式和地址指定方式</span>相结合进行寻址的存储器

*串行访问存储器*

补充两个存储器

SAM顺序存储器（一般对应的是生活中的磁带）

DAM直接存取存储器（磁盘）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308021536658.png)



### 存储器指标

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308021542084.png)



补充一个点

命中率的概念

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308021549569.png)

原理：CPU可以直接的从换主存或缓存当中取数据，我们知道上一层数据是下一层数据的副本且仅包含部分。CPU首先是会去缓存中查看是否有数据，如果有直接读取，如果没有就需要主存给于。



### 多层次的存储器系统

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308021542868.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308021542891.png)



### 总结

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308021539836.png)



## 主存储器

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031547988.png)

**内存包含了 <span style='color:#CE3C05'>RAM </span>和 <span style='color:#CE3C05'>ROM</span>**

可以结合操作系统的进程映像进行理解

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051744898.png)

可以发现操作系统内核区一定是常驻内存的，这里的1GB大概率也是使用的ROM进行存储的（因为不需要的经常的变动）

### SRAM芯片与DRAM芯片

SRAM又叫做静态<span style='color:#CE3C05'>半导体</span>存储器

DRAM又叫做动态半导体寄存器

注意 MOS 管是半导体器件。

1. SRAM的工作原理

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031548335.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031550106.png)

   双稳态：用两个电平表示不同的信息。1：A高B低， 0： A低B高

2. DRAM的工作原理

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031551236.png)

   刷新，是因为电容这个固件的特性（就像我们充电宝一样放着不用一样会没电），所以需要不断的给电容进行充电操作。这个操作也叫做刷新。

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031556457.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031556047.png)

   **注意**

   - 分散刷新，因为刷新时间是紧跟在读写时间之后，我们认为不存在连续读/写，所以<span style='color:#CE3C05'>分散刷新不存在死时间</span>。但是<span style='color:#CE3C05'>异步刷新是存在死时间</span>的，只不过是相对于集中刷新来说变得更加的短而已。
   - <span style='color:#CE3C05'>一次完成的刷新过程只需要使用一个读写周期</span>。具体来说：DRAM首先通过读取自己内部存储的信息，然后通过放大器将读取的信息重新写入存储体当中。

   

3. SRAM和DRAM的差别

   | 类型特点           | SRAM        | DRAM       |
   | ------------------ | ----------- | ---------- |
   | 存储信息           | 触发器      | 电容       |
   | 破坏性读出         | 非          | 是         |
   | 读出后是否需要重写 | 不用        | 需要       |
   | 运行速度           | 快          | 慢         |
   | 集成度             | 低          | 高         |
   | 发热量             | 大          | 小         |
   | 存储成本           | 高          | 低         |
   | 是否易失           | 易失        | 易失       |
   | 是否需要刷新       | 不需要      | 需要       |
   | 作用               | 常用作Cache | 常用作主存 |

   注意：易失性指的是断电易失。不是因为不刷新而不易失。

4. 存储器芯片的内部结构

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031559239.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031559651.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031559648.png)

5. DRAM采用的二维矩阵排列方式

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031608177.png)

   DRAM的地址线复用技术

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031609217.png)
   
   所以如果有 $2^n$个存储块，我们只需要有 $\frac{n}{2}$ 条地址线。但是同时由于我们存在了行列地址译码器，所以还需要两个行列片选线信号的输入。（相对于一维存储的区别）
   
   **注意**，题目要我们求存储器的引脚个数的时候，<span style='color:#CE3C05'>没有特别说明，都是认为这里的地址线复用。</span>

### 只读存储器（ROM)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031600447.png)

- <span style='color:#CE3C05'>EPROM</span>虽然可以进行擦除和读写操作，但是<span style='color:#CE3C05'>不能做为随机存储器</span>。因为EPROM只能有限的擦除，并且擦除的时间太长了，导致了写入操作过慢，所以不能作为随机存储器。
- <span style='color:#CE3C05'>RAM的读写速度是远比ROM的速度要快的。</span>（容易记错）
- ROM通常不作为随机存储器使用。
- 对于所有ROM来说，其读写的速度一般都是读快写忙，这是应为ROM的物理特性决定的，因为ROM在写之前大部分需要进行擦除的工作，由于ROM是不易失存储器，所以相对来说擦除都比较困难，所以写的速度都相对比较慢。
- SSD容易磨损
- ROM存储器也是半导体存储器

### 主存储器的基本组成

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031600462.png)

有些存储器由于存储容量比较大，如果单纯的按照一维的形式进行排列的话，这样的控制些数目太多（因为是指数函数，位数越多意味着可能会出现指数爆照的情况）

普通的一维排布的情况

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031603683.png)

如果要计算存储器芯片的引脚个数的话，就要的将地址线数据线、片选线和（一条或两条）读/写控制线



### 多模块存储器

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031611600.png)

#### 单体多字存储器

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031611013.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031611665.png)



#### 多体并行存储器

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031612170.png)

**多位交叉编制（顺序方式）**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031613171.png)

- 高体交叉存储器也是有可能同时访问多个模块存储器的（可能执行了不同的跳跃指令的吧，但是可能性比较小的，大部分的情况下由于程序的局部性原理导致最后也只能顺序的执行）


**低位交叉编制（交叉方式）**

在现实生活中双通道内存就是以低位交叉编址实现的。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031613362.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031613046.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031616032.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031617004.png)

- 低位多体交叉存储器能比较好的<span style='color:#CE3C05'>满足程序的局部性原理</span>

流水线操作是轮流存取，另外还有一种读取方式叫做同时存取。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051645188.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051649282.png)

比如说这一道题目，我们可以从数据宽度等于 $4(模块数) * 8bits = 32bits$，知道这里是同时启动的方式。

这里的还涉及到一个很重要的问题，存储器一次都是读取的是哪几个地址？

由于这里是采用的低位交叉编址的形式并且采用的是同时读取形式，所以每一次读取四个存储器模块，并且高位都一定是相同的。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308051653486.png)

低两位表达是体号，同一个行高位一定是相同的，只有低位不同。很好理解因为根据存储器的工作原理，CPU给出的地址线是同时传送到所有存储器模块当中的，然后通过3-8译码器或者其他译码器进行选着使用哪一个存储器模块。

**流水线例题**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308031613042.png)



## [主存储器与CPU的连接](https://www.icourse163.org/learn/kaopei-1467188162?tid=1468338443#/learn/content?type=detail&id=1254479594&cid=1285765369)

### 连接原理

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308071657815.png)

### 主存容量的扩展

#### 字扩展

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308071658413.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308071658857.png)

#### 位扩展

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308071658121.png)

- 一般在做题目的使用位扩展都是使用的<span style='color:#CE3C05'>高地址进行扩展</span>
- 结合低位交叉编址，其实就是片选线使用低位进行译码的选择
- 要注意最大容量和实际容量上的区别，MAR的位数主要还是取决于最大容量，而不是实际容量
- 如果地址线有18位，块内地址占15位地址线，但是现在只进行4位存储器的扩展，所以其实只需要使用两位的片选线信号，但是我们高位有三位，为了然存储器连续及可扩展的编址，所以会选用 $\color{red}{a_1,a_2}$这两位当中片选线信号

#### 字位同时扩展

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308071659179.png)

### 存储芯片的地址分配和片选

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308071700038.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308071700539.png)



## 外部存储器



### 磁盘存储器

**组成**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308121433898.png)



**磁记录原理**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308121434482.png)



**磁盘的性能指标**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308121434371.png)



**磁盘地址**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308121435450.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308121435954.png)



**磁盘阵列**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308121435292.png)



### 固态硬盘

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308121438744.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308121439324.png)



## 高速缓冲存储器

### 程序访问的局部性原理

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161910897.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161910276.png)







### Cache的基本工作原理

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161910679.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161911872.png)

- Cache保存的是主存块中的一个副本，所以在计算容量的时候Cache-主存容量为主存容量大小
- 我们可以知道处理<span style='color:#CE3C05'>CPU对Cache和主存的数据之间交流是以字节进行的</span>，其他的比如Cache和主存，主存和外存都是的<span style='color:#CE3C05'>以块为单位</span>进行数据的交换的（分配同理)
- 仅接着上一条，如果机器是以字节进行编址话，<span style='color:#CE3C05'>访问主存</span>，访问Cache这种存储的器依然是的以字节的进行的。注意这里是的<span style='color:#CE3C05'>访问而不是数据的交换</span>



![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161911846.png)



### Cache和主存的映射方式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161911094.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161912690.png)





#### 直接映射

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161912077.png)

**注意直接映射的地址结构是经常考察的，所以一定要会各个地址结构位数要如何计算**





#### 全相联映射

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161914217.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161914275.png)





#### 组相联映射

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161914149.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161915998.png)





![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161915223.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161915066.png)





#### 总结

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161916566.png)





### [Cache中主存块的替换算法](https://www.icourse163.org/learn/kaopei-1467188162?tid=1468338443#/learn/content?type=detail&id=1254491183&cid=1285758570)

#### 随机算法（RAND)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161920678.png)





#### 先进先出算法(FIFO)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161920648.png)







#### 近期最少使用算法（LRU)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161920700.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161920727.png)

- 一要与操作系统置换页面的LRU算法做联系，可以用os的技巧来处理组成原理LRU算法。两者都是使用的计数器来计算最近多久没有访问Cache





#### 最不经常使用算法(LFU)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161920757.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161920778.png)





#### Cache写策略

**在写命中前提下：**

#### 全写法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161933798.png)







#### 回写法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161934440.png)





**不命中情况下：**

#### 写分配法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161934218.png)





#### 非写分配法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161935780.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161935019.png)







### Cache有关计算

#### 容量计算

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308161940884.png)





#### 地址映射表

地址映射表保存的是Tag + 一些有效位/算法位/脏位

**为什么需要地址映射表？**

首先要知道Cache的地址位和主存的地址位是不同的，Cache的地址为会更加的短。而主存比Cache多出来的地址位就需要保存在地址映射表当中。如果我们只访问的Cache内存地址我们是不知道是哪一个主存快映射过来的，所以我们还需要的借助地址映射表找到是哪一个主存的块映射过来的。



# 第四章 指令系统

## 指令系统

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171518328.png)

- 指令系统是软件的最底层，硬件的最高层。是<span style='color:#CE3C05'>软硬件的界面</span>。
- ISA规定内容注意适当关注一下，22年考过



### 指令的基本格式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171518007.png)

- 地址码保存的是操作数的地址，除了特殊的指令之外地址码可能包含下一条要执行指令的地址
- 指令的字长一般为字节的整数倍，但是为了方便取指令，指令的长度可以为存储字长的整数倍





#### 零地址指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171519726.png)





#### 一地址指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171520846.png)

- 单地址指令可能有一个操作数，也可能有两个操作数（隐含寻址）




#### 二地址指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171520782.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171520928.png)







#### 三地址指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171520020.png)









#### 四地址指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171521858.png)







### 定长操作码指令格式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171524547.png)





### 拓展操作码指令格式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171524800.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171524857.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171526485.png)

- 如果严格的说，相同操作码位数的情况下，拓展操作码的指令数量上来说一定是比固定操作码位的指令数目要小的（这是前缀编码的特性）
- 但是如果说相同指令字长下，我们可以说扩展操作码保持了指令字长度不变而增加指令的数量。
- 扩张操作码在指令字长不变的情况下，丰富了指令的类型





**例题（要会下面的计算）**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171525597.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171525340.png)







### 指令的操作类型

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308171527443.png)

- 程序控制类指令功能是：改变程序执行的顺序

  

## 指令寻址

### 明确一些概念

- <span style='color:#CE3C05'>程序浮动</span>指**内存分配中，程序可能从内存的一部分移动到另外一部分**。
- 程序计数器的位数取决于存储器的字数（不能取决于地址总线的宽度，因为这样的话会可能导致指向一个空地址，会造成程序溢出）
- 指令寄存器(IR)用于接收取得的指令，因此取决于指令字长



### 指令寻址和数据寻址

**指令寻址**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201651953.png)

- 转移指令、子程序调用指令、返回指令。这些指令都是为了解决指令调用次序的需求，而不是数据调用次序的需求。



 **数据寻址**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201651049.png)



### 常见数据寻址方式

#### 隐含寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201652434.png)

- 简化地址结构最有效的方法



#### 立即数寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201652450.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201652858.png)

- 是获取操作数最快的方式





#### 直接寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201653788.png)

- 直接寻址是直接把有效地址<span style='color:#CE3C05'>放入到PC中</span>，而不是MAR



#### 间接寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201653814.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201653354.png)







#### 寄存器寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201654947.png)

- 寄存器寻址可以缩短地址段的位数（因为寄存器比较少，并且我们只用指明寄存器的号即可）
- ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201728501.png)





#### 寄存器间接寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201654803.png)









#### 相对寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201654138.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201654818.png)

- 因为便于<span style='color:#CE3C05'>程序的浮动</span>，所以是<span style='color:#CE3C05'>多道程序设计</span>中的最重要的寻址方式。





#### 基址寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201655182.png)

- 基址寄存器内容保存的是无符号数
- 基址寻址的时候使用的如果是专用寄存器BR进行保存基址的话，就不需要专门用一个段来指出来基址的编号。如果是通用寄存器的话，比如用一个字段来指出来基址寄存器的编号。





#### 变址寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201655188.png)









#### 堆栈寻址

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201655074.png)







#### 总结

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308201656916.png)





## 程序的机器级代码表示

### 常用汇编指令

**相关寄存器**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221640922.png)







**汇编指令格式(AT&T/Intel)**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221640148.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221640319.png)







**常用指令**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221642457.png)





**数据传送指令**

#### **mov指令**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221642338.png)





#### push指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221643517.png)







#### pop指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221643348.png)





**算术和逻辑运算指令**

#### add/sub指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221644964.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221644127.png)







#### Inc/dec指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221645912.png)





#### imul指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221645126.png)







#### idiv指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221645970.png)







#### and/or/xor指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221650887.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221650839.png)



#### not指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221650320.png)





#### shl/shr指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221650442.png)





**控制流指令**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221647718.png)







#### jmp指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221647845.png)



#### jcondition指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221648848.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221648466.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221649707.png)





#### cmp/test指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221649884.png)





#### call/ret指令

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221649007.png)



### [过程调用的机器级表示](https://www.icourse163.org/learn/kaopei-1467188162?tid=1468338443#/learn/content?type=detail&id=1254481256&cid=1285764620)

本节内容不太懂的话的建议看一下ppt,应为内容比较杂多,所以这里只做精简

**访问栈帧**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221712136.png)

- x86的机器当中栈一般以4字节为单位处理

**切换栈帧**

*函数调用*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221711899.png)

调用函数使用call指令,处理的是PC的值(因为无论如何最后我们都是需要的去相应的位置的去取得我们的函数的指令的,要取到指令就必须知道指令地址)

**enter指令**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221713441.png)



*函数返回*

`leave指令`

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221714394.png)

`ret指令`

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221715517.png)



**栈帧内容**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221719093.png)

- 注意局部变量在函数中的申请顺序和在栈帧存放的地址(先申请的变量会越靠近栈顶)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221719207.png)



**传递参数**

一般传递参数都是使用的`eax寄存器`

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221721799.png)

**总结**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221722718.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221723203.png)



### [循环结构语句的机器级表示](https://zhuanlan.zhihu.com/p/554546968)

本小节转载自知乎(点击上面是原知乎链接)

用条件指令实现循环

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221655040.jpg)

用loop指令实现循环

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308221655068.jpg)

就是将”某些处理“封装到了Looptop内，使得代码更加简洁。

四、CISC和RISC

| 对比项目         | CISC                 | RISC                     |
| ---------------- | -------------------- | ------------------------ |
| 指令系统         | 复杂，庞大           | 简单，精简               |
| 指令数目         | 一般大于200条        | 一般小于100条            |
| 指令字长         | 不固定               | 定长                     |
| 可访存指令       | 没有限制             | 只有Load/Store指令       |
| 各种指令执行时间 | 相差较大             | 绝大多数在一个周期内完成 |
| 各指令使用频率   | 有的常用，有点不常用 | 一般都常用               |
| 通用寄存器的数量 | 较少                 | 多                       |
| 控制方式         | 绝大多数为微程序控制 | 绝大多数为组合逻辑控制   |
| 指令流水线       | 可以通过一定方式实现 | 必须实现                 |







# 第五章 中央处理器

## CPU的功能和基本结构



### CPU的功能

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308311521510.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308311521811.png)

- 在所谓的n位CPU中，n是指数据总线线数



### CPU的基本结构

#### 

#### 运算器

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308311522343.png)





#### 控制器

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308311522991.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202308311522543.png)
