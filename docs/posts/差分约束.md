---
title: 差分约束
date: 2022-07-19 20:05:33
tags:
- 差分约束
- 图论模版
- 笔记
categories: 
- 模版
- 图论
- 差分约束
---

## 差分约束
### 应用一：求解不等式组的可行解（只能求解出来一个组）
不等式组的的表示形式一般也有两种
```
只有相对值的性质
x1 <= x2 + c1
x2 <= x3 + c2
x3 <= x1 + c3
（只含有相对值，是不能可以有最大最小值的，因为没有定值约束）
```
```
含有一个绝对参数
x1 <= x2 + c1
x2 <= x3 + c2
x3 <= x1 + c3
x1 >= 0(0是坐标系中的绝对地址)
```
从不等式的形式转换成图的形式
dist[x1] <= dist[x2] + c1
**构造： 这里从x2->x1连上一条权值为c1的边**
*这里的dist数组维护的是点x到源点的最短距离*
反证法：如果dist[x2] + c1 < dist[x1]的话，那么就说明x1到源点的最短路径应该是从x2到源点的最短路径在经过c1边到x1，所以x1的最短路径是可以被更新的

要知道这些不等式集合是不一定是可解的，所以要求其可行解先，我们应该判断其是否有解。
判断是否有解？
结论：
1. **x1 <= x2 + c1这种形式，图中没有负环的情况下是有解的**
```
    x1 <= x2 + c1
    x2 <= x3 + c2
    x3 <= x1 + c3
```
    证明角度一：不等式运算
    我们可以把上面三个不等式加起来，可以得到`x1 + x2 + x3 <= x1 + x2 + x3 + c1 + c2 + c3`
    化简可得`0 <= c1 + c2 +c3` 得到`c1 + c2 + c3 `大于等于0是是有解的，`c1 + c2 + c3`是路径包含了x1,x2,x3的环，也就是当图中没有负环的时候是有解的。
    证明角度二：放缩
    `x1 <= x2 + c1 <= x3 + c1 + c2 <= x1 + c1 + c2 + c3`,化简得到 `x1 <= x1 + c1 + c2 + c3`,很明显仅当`c1 + c2 + c3 <= 0 `的时候不等式才会成立

2. **x1 >= x2 + c1这种形式，图中没有正环的情况下是有解的**

在确定完了有解的情况下，我们求解不等式的可行解
我们从上面我们转换成图论问题使用了dist数组，表示到源点的最短/最长距离，所以我们首先要构造出来一个源点。
源点需要满足的条件：从源点出发，一定是可以达到所以的**边**的。
这里是什么源点是一定达到所有的边而不是所有的点呢？？ 很显然如果不能到达这个点的话，那么说明这个点是孤立点，孤立点不受到任何的约束，所以孤立点是可以去取得任何的值

#### 步骤：
1. 先将每个不等式 xi <= xj + cj 转换成一条j->i边权为cj的边
2. 构造出一个超级源点（虚拟源点），使得源点一定是可以遍历到所有的边的
3. 从源点求一遍单源最短路
   1. 结果1:如果有负环，则原不等式组一定无解
   2. 结构2:如果没有负环，则dist[i]就是原不等式组的一个可行解
   
### 应用二：求解最大值/最小值（每个值的最大值和最小值）
现的
**结论：如果求的是最小值话，则应该求最长路，如果求的是最大值的话，则应该求最短路**
证明：以求xi的最小值为例
首先我们要知道这个不等式组一定是形式二，应为只有相对位置，没有绝对坐标约束是不可能有最大最小值的。
我们可以通过放缩（应用一的放缩思想）构造出来一些不等式`xi <= xj + cj <= ...<= 0(xi >= 0) + c1 + c2 + c3..+cn`,这里的c1，c2..是到xi的边，因为到xi的路径有可能有很多条所以，所以要想满足所有的xi <= c1 + ... + cn 的不不等式，我们只能取的上确界，也就是取所有路径的最大值，就一定满足所有的不等式了。**于是就将求x的最小值转换成最长路径**

#### 步骤：
建立一个超级源点，0，然后建立0->i,边权为c的边(绝对参考值)
计算出所有的上界/下界，最终的xi的最大值（最小值）等于所有上界（下界）的最小值（最大值）

#### 注意 与 总结
* 我们上面的不等式组一定是可以统一成大于等于/小于等于的形式（大于等于和小于等于都是同时存在的，因为有两个变量在不等式的两边，假如对于不等式左边的变量是大于等于，那么就对于不等式右边的变量是小于等于）
* 求最小值的时候把不等式组统一形式成 a >= b + c1, 把所有的常量（可正可负）都移到不等式的右边，b向a连上一条权值为c1的边（因为求最小值，等于求最长路，dist[a] >= dist[b] + c1, 反证法 b向a有一条权值为c1的边，如果b的最长路径加上一条b->a路径比原来a的最长路径要大的话，那么就需要对a的最长路径进行更新，矛盾所以我们构造边成立）
* 求最大值的时候把不等式组统一形式成 a <= b + c1, `b`向`a`连上一条权值为c1的边
* 转化不等式组：a > b 可以等价于 a >= b + 1
* 最小值（最长路） 正环无解， 最大值（最短路） 负环无解


### 例题 [AcWing 1169. 糖果](https://www.acwing.com/problem/content/1171/)

#### 题目
幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。

但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候， 老师需要满足小朋友们的 K 个要求。

幼儿园的糖果总是有限的，老师想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。

输入格式
输入的第一行是两个整数 N,K。

接下来 K 行，表示分配糖果时需要满足的关系，每行 3 个数字 X,A,B。

如果 X=1．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。
如果 X=2，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。
如果 X=3，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。
如果 X=4，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。
如果 X=5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。
小朋友编号从 1 到 N。

输出格式
输出一行，表示老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 −1。

数据范围
1≤N<105,
1≤K≤105,
1≤X≤5,
1≤A,B≤N

Input
```
5 7
1 1 2
2 3 2
4 4 1
3 4 5
5 4 5
2 3 5
4 5 1
```
Output
```
11
```
#### 题解
题目要求求最小值，先化简不等式组，判断是否有正环，没有正环，求解最长路

### CODE
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head

const int N = 100010, M = 200010;

int n,k;
int h[N], e[M], w[M], ne[M], idx;
int cnt[N];
ll dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;
}


bool spfa()
{
    // 使用stack判断正环
    memset(dist, -0x3f,sizeof dist);
    dist[0] = 0; 
    int q[N];
    int hh = 0, tt = 1;
    q[0] = 0;
    st[0] = true;

    while(hh != tt)
    {
        int t = q[--tt];
        st[t] =false;

        for(int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if(dist[j] < dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if(cnt[j] >= n + 1) return false;
                if(!st[j])
                {
                    q[tt ++] = j;
                    st[j] = true;
                }
            }
        }
    }
    return true;

}


int main()
{
    cin >> n >> k;
    memset(h, -1, sizeof h);
    for(int i = 0; i < k; i ++)
    {
        int a,b,x;
        scanf("%d%d%d",&x,&a,&b);
        // 因为要求的是最小值，所以我们需要找最长路径，并构造>=的形式
        if(x == 1) add(a,b,0),add(b,a,0);
        else if(x == 2) add(a,b,1);
        else if(x == 3) add(a,b,0); // 边权为0就无所谓方向了
        else if(x == 4) add(b,a,1);
        else if(x == 5) add(a,b,0);
    }

    // 构造超级源点
    // 由于上面的不等式为相对值，没有绝对值得情况下是无法求的最值问题的
    // 我们由题意知所有小朋友都会得到糖果所以，每个朋友至少为一，所以构造虚拟源点时候，初始化为1就可以表示为绝对参考系
    for(int i = 1; i <= n; i++)
        add(0,i,1);

    if(!spfa()) puts("-1");
    else 
    {
        ll res = 0;
        for(int i = 1; i <= n; i ++) res += dist[i];
        printf("%lld\n", res);
    }


    return 0;
}
```



```c++
void del_min(LinkList &L){
    LNode *p = L, *Loc = L; // Loc 记录的是最小值前面的节点
    int minx = INF; // INF是一个值表示是无穷大
    while(p->next != NULL){
        LNode *s = p->next;
        int x = s.data;
        if(minx > x){
            minx = x; // update the value of minx
            loc = p;
        }
    }

    // del min value
    p = loc->next;
    loc->next = loc->next->next;
    free(p);
}
```

