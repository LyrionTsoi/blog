---
title: HDU-4857 逃生
date: 2022-07-20 20:08:44
tags:
- 图论
- 拓扑排序
- 类字典序问题
categories: 
- - 图论
- - 拓扑排序
- HDU
---

## [HDU-4857 逃生](https://vjudge.net/problem/HDU-4857)
糟糕的事情发生啦，现在大家都忙着逃命。但是逃命的通道很窄，大家只能排成一行。

现在有n个人，从1标号到n。同时有一些奇怪的约束条件，每个都形如：a必须在b之前。
同时，社会是不平等的，这些人有的穷有的富。1号最富，2号第二富，以此类推。有钱人就贿赂负责人，所以他们有一些好处。

负责人现在可以安排大家排队的顺序，由于收了好处，所以他要让1号尽量靠前，如果此时还有多种情况，就再让2号尽量靠前，如果还有多种情况，就让3号尽量靠前，以此类推。

那么你就要安排大家的顺序。我们保证一定有解。
Input
第一行一个整数T(1 <= T <= 5),表示测试数据的个数。
然后对于每个测试数据，第一行有两个整数n(1 <= n <= 30000)和m(1 <= m <= 100000)，分别表示人数和约束的个数。

然后m行，每行两个整数a和b，表示有一个约束a号必须在b号之前。a和b必然不同。
Output
对每个测试数据，输出一行排队的顺序，用空格隔开。

Sample
Input
```
1
5 10
3 5
1 4
2 5
1 2
3 4
1 4
2 3
1 5
3 5
1 2
```
Output
```
1 2 3 4 5
```

### 题解
**要注意的是本题不是字典序问题，而是要让小的编号尽量靠前**，字典序问题我们很清楚一般都是可以利用贪心来做，因为字典序每一步都需要要最小，每一步都是局部最优，最后必然是全局最优的。但是编号小的尽可能靠前则不同，应为到编号为i的前面数可以能是很大的值，只要将i排列到所有合法方案的最前面，才是编号小靠前问题，是不能使用贪心来求解的。
**但是我们知道小的值不一定在前面，但是大的值一定在后面**,于是我们对于编号问题就需要使用逆向建图，使用大根堆进行维护，然后答案保存在vector，倒序输出
**字典序问题就使用小根堆进行维护，每一步都是局部最优**

### CODE
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head

const int N = 30010, M = 100010;

int h[N], e[M], ne[M], idx;
int n,m;
int d[N];
priority_queue<int> q;
vector<int> ans;

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void topsort()
{
    for(int i = 1; i <= n; i ++)
        if(!d[i])
            q.push(i);

    while(q.size())
    {
        int t = q.top();
        ans.pb(t);
        q.pop();
        for(int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if( -- d[j] == 0)
            {
                q.push(j);
            }
        }
    }
}

int main()
{
    int T;
    cin >> T;
    while(T --)
    {
        cin >> n >> m;
        memset(h,-1,sizeof h);
        memset(d,0,sizeof d);
        ans.clear();
        idx = 0;

        for(int i = 0; i < m; i ++)
        {
            int a,b;
            scanf("%d%d",&a,&b);
            add(b,a);
            d[a] ++;
        }

        topsort();
        for(int i = n-1; i > 0; i --) cout << ans[i] << ' ';
        cout << ans[0] << endl;
        }
    return 0;
}
```