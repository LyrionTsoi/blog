---
title: 最短路问题
date: 2022-07-18 10:31:43
tags:
- 笔记
- 图论
categories:
- 模版
- 图论
- 最短路
---


## 最短路问题

### Bellman_ford算法
每次对所有边进行松弛操作，并迭代n次最后得到的就是单源最短路。
主要用于
1. 求含有负环的最短路
2. 求有边数限制的最短路
*因为有了spfa对bellman的优化，所以一般情况下不是求边数限制的话，不会用到bellman算法*

步骤：
```
for 迭代n次（一个图中不含有环的最短路最长边数位n-1条边）  
     for 对每一条边（m条）进行松弛
```

因为内层对每一条边进行松弛，所以可能到不了的边最后也会被更新为非INF，所以在判断是否有最短路不能通过是否等于INF来判断，要通过INF/2来判断

### 模版
例题 [AcWing853. 有边数限制的最短路](https://www.acwing.com/problem/content/description/855/)

```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).bEdgein(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head

const int N = 510, M = 10010;

int n,m,k;
int dis[N];

struct Edge
{
    int a,b,d;
    // Edge():a(),b(),d(){}
    // Edge(int a, int b, int d): a(a), b(b),d(d){}
}Edge[M];

int main()
{
    cin >> n >> m >> k;
    for(int i = 0; i < m; i ++)
    {
        cin >> Edge[i].a >> Edge[i].b >> Edge[i].d;
    }

    memset(dis, 0x3f, sizeof dis);
    int bak[N];
    dis[1] = 0;
    for(int i = 0; i < k; i ++)
    {
        memcpy(bak,dis,sizeof dis);
        for(int j = 0; j < m; j ++)
        {
            int a = Edge[j].a, b = Edge[j].b;
            int d = Edge[j].d;
            dis[b] = min(dis[b],bak[a] + d);
        }
    }

    int res = dis[n];
    if(res > INF / 2) cout<< "impossible" << endl;
    else cout << res << endl;

    return 0;
}
```

### SPFA算法
对`bellman`的优化，因为`bellman`每次都松弛每一条边，但是这种对每一条边都进行松弛是有大量重复的操作的，是没有意义的。所以`spfa`使用了队列（循环队列）来进行优化，每次将元素出队，有且只会对这个元素的邻边进行更新。

存储方式：使用一个类邻接表的形式，树链前向星。

### 例题[spfa求最短路](https://www.acwing.com/problem/content/853/)
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。

数据保证不存在负权回路。

输入格式
第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

输出格式
输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 impossible。

数据范围
1≤n,m≤105,
图中涉及边长绝对值均不超过 10000。

Input
```
3 3
1 2 5
2 3 -3
1 3 4
```
Output
```
2
```

### CODE
```C++
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>

using namespace std;

const int N = 100010, inf = 0x3f3f3f3f;

int h[N], e[N], w[N], ne[N], idx;
int n, m;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

void spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q;   // stl里面的queue本质上就是一个循环队列
    q.push(1);
    st[1] = true;
    
    while(q.size())
    {
        int t = q.front();
        q.pop();
        st[t] = false;
        
        for(int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
                if(dist[j] > dist[t] + w[i])
                {
                    dist[j] = dist[t] + w[i];
                    if(!st[j])
                    {
                        q.push(j);
                        st[j] = true;
                    }
                }
        }
    }
    
}

int main()
{
    cin>>n>>m;
    
    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c;
        cin>>a>>b>>c;
        
        add(a, b, c);
    }
    
    spfa();
    
    if(dist[n] > inf / 2) puts("impossible");
    else printf("%d\n", dist[n]);
    
    return 0;
}
```
手写循环队列的spfa版块
```C++
int spfa()
{
    memset(dis, 0x3f, sizeof dis);
    dis[S] = 0;

    int q[N];
    int hh = 0, tt = 1;
    q[hh] = S, st[S] = true;

    while(hh != tt)
    {
        int t = q[hh ++];
        if(hh == N) hh = 0;
        st[t] = false;  // 这里的状态不同与dijkstra这里是表示的是否在队列当中，一个节点可能被多次更新
        // spfa的过程等于 要想求的i～j之间的最短路，每次更新就在i～j的路径上再加一个节点
        for(int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if(dis[j] > dis[t] + w[i])
            {
                dis[j] = dis[t] + w[i];
                if(!st[j])
                {
                    q[tt ++] =  j;
                    if(tt == N) tt = 0;
                    st[j] = true;
                }
            }
        }
    }
    return dis[T];
}
```

### O（n^2) dijkstra
外层迭代n次，每次选取到源点的最小值，维护dist数组（要注意与最小生成树中的dist数组做区分，最小生成树的中的dist数组是维护到连通块的最小值，在最短路问题中是维护的是到源点的最小值），由于dist是每个点到别的顶点的最短距离，所以内层也是迭代n遍
用选出来的这个点对其他点进行更新dist（如果对更新有别的决策要写入到更新边的板块中）
如：双权值，dijkstra问题[最短路径问题](https://vjudge.net/problem/HDU-3790),在板子后面会贴出代码

#### 例题[Dijkstra求最短路](https://www.acwing.com/problem/content/851/)
```C++
#include<bits/stdc++.h>

using namespace std;

const int N = 510, inf = 0x3f3f3f3f;

int g[N][N];
int dist[N];
bool st[N];
int n, m;

void dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for(int i = 0; i < n - 1; i ++)
    {
        int t = -1;
        for(int j = 1; j <= n; j ++)
            if(!st[j] && (t == -1 || dist[j] < dist[t]) ) t = j;

        st[t] = true;

        for(int j = 1; j <= n; j ++)
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }
}

int main()
{
    cin >> n >> m;

    memset(g, 0x3f, sizeof g);
    for(int i = 0; i < m; i ++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = min(g[a][b], c);
    }

    dijkstra();

    if(dist[n] != inf) cout << dist[n] << endl;
    else cout << -1 << endl;

    return 0;
}
```
双权值问题
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head

const int N = 1010, M = 100010;

int g[N][N];
int cost[N][N];
int n, m; 
bool st[N];
int dist[N];
int val[N];

void dijkstra(int start)
{
    // 双关键值 最短路问题
    memset(dist, 0x3f, sizeof dist);
    memset(val,0x3f, sizeof val);
    memset(st, 0, sizeof st);

    dist[start] = 0;
    val[start] = 0;
    for(int i = 0; i < n; i ++)
    {
        int t = -1;
        for(int j = 1; j <= n; j ++)
            if(!st[j] && (t  == -1 || dist[j] < dist[t]))
                t = j;
        st[t] = true;
        // 与单权值问题的区别
        for(int j = 1; j <= n; j ++)
        {
            if(dist[j] > dist[t] + g[t][j])
            {
                dist[j] = dist[t] + g[t][j];
                val[j] = val[t] + cost[t][j];//即使这里比原来花费的要更大的话也要更新，因为他们是有联系的
            }
            else if(dist[j] == dist[t] + g[t][j] && val[j] > val[t] + cost[t][j])
            {
                val[j] = val[t] + cost[t][j];
            }
        }
    }
}


int main()
{
    while(scanf("%d%d",&n,&m), n)
    {
        int a,b,d,p;
        memset(g,0x3f,sizeof g);
        memset(cost, 0x3f, sizeof cost);

        for(int i = 0; i < m; i ++)
        {
            scanf("%d%d%d%d",&a,&b,&d,&p);
            if(g[a][b] > d)
            {
                // 花费和边长是相互挂钩的
                g[a][b] = g[b][a] = d;
                cost[a][b] = cost[b][a] = p;
            }
            else if(g[a][b] == d && cost[a][b] > p)
            {
                cost[a][b] = cost[b][a] = p;
            }
        }

        int s,e;
        scanf("%d%d",&s,&e);
        dijkstra(s);

        cout << dist[e] << ' ' << val[e] << endl;
    }
    return 0;
}
```

### O（mlogn）的dijkstra
**对于dijkstra算法和bfs算法都是一样的，每个点只会别迭代一次，迭代完了之后就不会再被更新。**所以一般会在这做优化如果st[i] = true, 就直接跳过更新这个点，而spfa中的st[i]记录的是i点这个点是否在队列当中，spfa不一样的是每个点是可以被更新多次的（所以这个性质也经常被用于求负环当中）
**实际上堆优化版的dijkstra就是优先队列bfs**，只不过其实现在不同类型的图，假如是给定的图是迷宫图给出了一个迷宫的形状，我们只能上下左右走，那么应该使用bfs。在一些标定图（每个点都标定好编号）使用dijkstra比较方便

### 例题[Dijkstra求最短路 II](https://www.acwing.com/problem/content/852/)
给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

输入格式
第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

输出格式
输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

数据范围
1≤n,m≤1.5×105,
图中涉及边长均不小于 0，且不超过 10000。
数据保证：如果最短路存在，则最短路的长度不超过 109。

输入样例：
```
3 3
1 2 2
2 3 1
1 3 4
```
输出样例
```
3
```

### CODE
```C++
#include<bits/stdc++.h>

using namespace std;

typedef pair<int, int> PII;

const int N = 200010;

int h[N], e[N], ne[N], w[N],idx;
int n, m;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

void dijkstra()
{
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    heap.push({0, 1});

    while(heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second;

        if(st[ver]) continue;   // 表示这个点的子节点是否有更新，更新过了接下来就不需要再更新了
        st[ver] = true; // 堆优化的对状态进行判断主要的同bfs一样，每个节点的只会更新一遍，防止其重复更新才做判断（防止走回头路）

        for(int i = h[ver]; ~i; i = ne[i])
        {
            int j = e[i];

            if(dist[ver] + w[i] < dist[j])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }

    }
}

int main()
{
    cin >> n >> m;

    memset(h, -1, sizeof h);
    while(m --)
    {
        int a, b, c;
        cin >> a >> b >> c;

        add(a, b, c);
    }

    dijkstra();

    if(dist[n] != 0x3f3f3f3f) cout << dist[n] << endl;
    else cout << -1 << endl;

    return 0;
}
```
