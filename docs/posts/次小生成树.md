---
title: 次小生成树
date: 2022-07-14 14:04:16
tags:
- 次小生成树
- 图论模版
- 笔记
categories: 
- 模版
- 图论
- 次小生成树
---

## 次小生成树

### 定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树
**非严格次小生成树的权值 >= 最小生成树**  
**严格次小生成树的权值 > 最小生成树**   
  

### 求解思路
**方法一**：先求最小生成树，再枚举删去最小生成树中的边求解。*要注意*本方法不能求解严格次小生成树。 时间复杂度为O(mlogm + nm)
**方法二**：先求最小生成树，然后依次枚举非树边，然后将改变加入树中，同时从树中去掉一条边，使得最终的图仍是一颗树。则最后一定会得到一颗次小生成树。

方法二的证明。我们在最小生成树上加入一条非树边一定会形成一个环，由于我们的kruskal算法选择策略是按不连通块之间最小边来选，所以当前加入的这一条非树边一定是>=环上的任意一条边的。如果加入的这一条非树边严格>环上的任意一条边，那么最后我们可以得到一颗严格次小生成树，否则为非严格次小生成树。

定理：次小生成树一定在最小生成树的邻集中。// 也就是说一定有一颗次小生成树（无论严格次小还是非严格）仅与最小生成树差一条边

### 求解过程
**这里主要是对方法二**  
1. 求最小生成树，统计标记每条边是树边还是非树边；同时把最小生成树建立出来
2. 预处理人任意两点间的边权最大值
3. 一次枚举所有非树边，求min(sum + w - dist[a][b])，满足w > dist[a][b] 

### 例题  [秘密的牛奶运输](https://www.acwing.com/problem/content/1150/) 
农夫约翰要把他的牛奶运输到各个销售点。

运输过程中，可以先把牛奶运输到一些销售点，再由这些销售点分别运输到其他销售点。

运输的总距离越小，运输的成本也就越低。

低成本的运输是农夫约翰所希望的。

不过，他并不想让他的竞争对手知道他具体的运输方案，所以他希望采用费用第二小的运输方案而不是最小的。

现在请你帮忙找到该运输方案。

注意：：

如果两个方案至少有一条边不同，则我们认为是不同方案；
费用第二小的方案在数值上一定要严格大于费用最小的方案；
答案保证一定有解；
输入格式
第一行是两个整数 N,M，表示销售点数和交通线路数；

接下来 M 行每行 3 个整数 x,y,z，表示销售点 x 和销售点 y 之间存在线路，长度为 z。

输出格式
输出费用第二小的运输方案的运输总距离。

数据范围
1≤N≤500,
1≤M≤104,
1≤z≤109,
数据中可能包含重边。

输入样例：
```
4 4
1 2 100
2 4 200
2 3 250
3 4 100
```
输出样例：
```
450
```

### CODE
#### 朴素版本（可以在求(a,b)上的最大边作优化，这里是朴素版本所以使用的是dfs）
```c
#include <vector>
#include <cstring>
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <map>
#include<cmath>

#define LL long long
#define pii pair<int,int>x

using namespace std;

const int INF = 0x3f3f3f3f, N = 510, M = 10010;

int f[N];
int h[N], e[N * 2], ne[N * 2], w[N * 2], idx;
int d1[N][N], d2[N][N]; //d1表示a到b上的这个最长树边，d2表示次长树边
int n, m;

struct edge{
    int a, b, w;
    bool f; // 标记这条边是否在树边
    bool operator <(const edge &t) const
    {
        return w < t.w;
    }
}eg[M];

void add(int a, int b, int c)
{
    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;
}

int find(int x)
{
    if(f[x] != x) f[x] = find(f[x]);
    return f[x];
}

// maxd1到u节点最长树边，同理maxd2， 这里的d1[]是对d1[i][]的二维操作
void dfs(int u, int father, int maxd1, int maxd2, int d1[], int d2[])
{
    d1[u] = maxd1, d2[u] = maxd2;
    for(int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        int v = w[i];
        if(j != father)
        {
            int nd1 = maxd1, nd2 = maxd2;
            // v等于最大值的时候不要更新，最大值和次大值相等的情况是没有意义的
            if(v > nd1) nd2 = nd1, nd1 = v;
            else if(v > nd2 && v < nd1) nd2 = v;
            dfs(j,u,nd1,nd2,d1,d2);
        }
    }
}

int main()
{
    cin >> n >> m;
    // build
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i ++)
    {
        int a,b,c;
        cin >> a >> b >> c;
        eg[i] = {a,b,c, false};
    }
    // init
    for(int i = 1; i <= n; i ++) f[i] = i;
    sort(eg, eg + m);
    // kruskal
    LL sum = 0;
    for(int i = 0; i < m; i ++)
    {
        int a = eg[i].a, b = eg[i].b, w = eg[i].w;
        //因为我们需要在构造最小生成树的情况下同时建图，所以切记使用a=find(a)
        int pa = find(a), pb = find(b);
        if(pa != pb)
        {
            f[pa] = pb;
            sum += w;
            eg[i].f = true;
            add(a,b,w);
            add(b,a,w);
        }
    }
    // init d1[],d2[]
    for(int i = 1; i <= n; i ++) dfs(i,-1,-1e9,-1e9,d1[i],d2[i]);

    LL res = 1e18;
    for(int i = 0; i < m; i ++)
    {
        if(!eg[i].f)
        {
            int a = eg[i].a, b = eg[i].b, v = eg[i].w;
            // 这里是严格次小生成树
            // 非严格在这里变化
            LL t;
            if(v > d1[a][b]) t = sum + v - d1[a][b];
            else if(v > d2[a][b]) t = sum + v - d2[a][b];
            res = min(res, t);  //最好使得两边都是相同的类型
        }
    }

    printf("%lld\n",res);

    return 0;
}
```

#### 优化版本（待续）