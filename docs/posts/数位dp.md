---
title: 数位dp
date: 2022-08-03 11:25:15
tags:
- 数位dp
- 模版
categories:
- 模版
- 数位dp
---

## 简介
[引用OI.WIKI](https://oi.wiki/dp/number/)

数位：把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。

数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：

1. 要求统计满足一定条件的数的数量（即，最终目的为计数）；

2. 这些条件经过转化后可以使用「数位」的思想去理解和判断；

3. 输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；

4. 上界很大（比如 $10^{18}$），暴力枚举验证会超时。

数位 DP 的基本原理：

考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。

数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减（即 $\mathit{ans}_{[l, r]} = \mathit{ans}_{[0, r]}-\mathit{ans}_{[0, l - 1]}$

那么有了通用答案数组，接下来就是统计答案。统计答案可以选择记忆化搜索，也可以选择循环迭代递推。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。

### 例题[AcWing 1081. 度的数量](https://www.acwing.com/problem/content/1083/)
求给定区间 [X,Y] 中满足下列条件的整数个数：这个数恰好等于 K 个互不相等的 B 的整数次幂之和。

例如，设 X=15,Y=20,K=2,B=2，则有且仅有下列三个数满足题意：

17=24+20
18=24+21
20=24+22
输入格式
第一行包含两个整数 X 和 Y，接下来两行包含整数 K 和 B。

输出格式
只包含一个整数，表示满足条件的数的个数。

数据范围
1≤X≤Y≤231−1,
1≤K≤20,
2≤B≤10
输入样例：
```
15 20
2
2
```
输出样例：
```
3
```
### 题解
 题目要求我们每个位置上的系数只能为一,因为进制数都是可以看作带权展开的，如十进制数：921， 9*10^2 + 2*10^1 + 1*10^0，这里的921就是按权展开的系数
 数位dp甚至是所有dp问题主要问题都是的在于分类讨论或者划分
 数位dp问题的划分（看成一颗树状会更好的划分问题)左分支位0~an-1, 右分支是an,所以一般是要结合当前位置的限位数来的填树的，然后把左右分支的所有的情况加起来就是我们所求的方案总数。
对于本题的填数
当前位置如果为0的情况：那么这位置上只能有右分支且为0（为了方便统一形式把填0的情况都统一在左分支上）
当前位置如果为1的情况，左分支只能填0，右分支填1
当前位置如果>1的情况，同上。

实在不理解可以看[这位同学的博客](https://lishizheng.blog.csdn.net/article/details/113665599)
### CODE
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 35;

int l,r,K,B;
int C[N][N];

// 预处理C(i,j) = C(i-1, j) + C(i-1, j-1)
void init()
{
    for(int i = 0; i < N; i ++)
        for(int j = 0; j <= i; j ++)
        {
            if(!j) C[i][j] = 1;
            else C[i][j] = C[i-1][j-1] + C[i-1][j];
        }
}

int dp(int x)
{
    if(!x) return 0;

    vector<int> nums;
    // 把x数值转换成B进制，倒着存放进数组内部
    while(x) nums.pb(x%B), x /= B;

    int res = 0;    // 表示[0,r]上有多少个合法的数
    int last = 0;   // 在本题记录的是从当前位置之前出现1的次数
    for(int i = nums.size() - 1; i >= 0; i --)
    {
        int x = nums[i];
        // 题目要求我们每个位置上的系数只能为一（因为进制数都是可以看作带权展开的，如十进制数：921， 9*10^2 + 2*10^1 + 1*10^0，这里的921就是按权展开的系数)
        // 数位dp甚至是所有dp问题主要问题都是的在于分类讨论或者划分
        // 数位dp问题的划分（看成一颗树状会更好的划分问题)左分支位0~an-1, 右分支是an
        // 因为每位上只能填0/1,我们要需要结合限位数来讨论
        // 当这一位上的数是0（<1)，那我们这一位就只能填0，如果这一位上的数>=1,那么这一位如果填0，后面的数随便填，如果这一位数上填一，后面的数还需要重新再讨论（重复上面的讨论）
        if(x)   // 左边分支
        {
            // 首先这一位上一定是可以放上的是0，所以应该是后面这么多位上可以选这K-last个1
            res += C[i][K - last];
            if(x > 1)
            {   
                // 当前位填1，从剩下的所有位（共有i位）中选K-last-1个数 
                if(K - last - 1 >= 0) res += C[i][K - last - 1];
                // 表示如果x>1的话就应该是分类讨论右分支(右分支是要等于an的，但是an大于一，又因为本题的要求系数只能为0/1，所以x>1是不存在右分支的状况所以要剪枝break掉)
                break;
            }
            else    // x == 1
            {   
                // 表示当前位填一
                last ++;
                if(last > K) break;
            }
        }
        if(!i && last == K) res ++; // 最右侧分支上的方案
    }
    return res;
}

int main()
{   
    cin >> l >> r >> K >> B;

    init();

    // dp(r)表示的前r个数里有多少个满足条件的
    cout << dp(r) - dp(l-1) << endl;
    
    return 0;
}
```