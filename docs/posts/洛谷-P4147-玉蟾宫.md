---
title: 洛谷 - P4147 玉蟾宫
date: 2022-07-16 12:16:41
tags:
- 单调栈
categories: 
- - 数据结构
---

## [玉蟾宫](https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P4147)

有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。

Description
这片土地被分成 N\times MN×M 个格子，每个格子里写着 'R' 或者 'F'，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。

现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 'F' 并且面积最大。

但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 SS，它们每人给你 SS 两银子。

Input
第一行两个整数 NN，MM，表示矩形土地有 NN 行 MM 列。

接下来 NN 行，每行 MM 个用空格隔开的字符 `F` 或 `R`，描述了矩形土地。

Output
输出一个整数，表示你能得到多少银子，即 （3×最大 `F` 矩形土地面积) 的值。

Sample
Input
```
5 6 
R F F F F F 
F F F F F F 
R R R F F F 
F F F F F F 
F F F F F F
```
Output
```
45
```

## 题解
枚举每一行，每一个的每一个位置连续F的最高高度，在每一行都做一次直方图最大面积
用dp[i][j] 记录（i,j)这个点往上的最高高度，如果（i，j）这个点存放的字符是`F`的话，那么dp[i][j] = dp[i-1][j] + 1,如果这个点存放的数据不是`F`的话那么dp[i][j] = 0

### CODE
```c
#include <vector>
#include <cstring>
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <map>
#include<cmath>

#define LL long long
#define pii pair<int,int>


using namespace std;

const int INF = 0x3f3f3f3f, N = 1010;

char mp[N][N];
int st[N],l[N],r[N];  // 每一行往上都可以构造成一个直方图最大矩阵问题，所以在这记录的是单调增
int n, m;
int dp[N][N];   // 枚举每一行的每一个位置看这个位置往上有多少个连续的F

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++)
        for(int j = 1; j <= m; j ++)
        {
            char c;cin >> c;
            mp[i][j] = c;
            if(c == 'F') dp[i][j] = dp[i-1][j] + 1;
            else dp[i][j] = 0;
        }    

    int res = 0;
    for(int i = 1; i <= n ; i ++)
    {
        // 单调栈处理当前这行往上的矩形最大面积问题
        int hh = 0; st[hh] = 0;
        for(int j = 1; j <= m; j ++)
        {
            while(hh && dp[i][st[hh]] >= dp[i][j]) hh --;
            l[j] = st[hh] + 1;
            st[++hh] = j;
        }

        hh = 0, st[hh] = m + 1;
        for(int j = m; j >= 1; j --)
        {
            while(hh && dp[i][st[hh]] >= dp[i][j]) hh --;
            r[j] = st[hh] - 1;
            st[++hh] = j;
        }

        for(int j = 1; j <= m; j ++)
        {
            int s = (r[j] - l[j] + 1) * dp[i][j];
            res = max(res, s);
        }
    }

    cout << res * 3 << endl;
    return 0;
}
```
