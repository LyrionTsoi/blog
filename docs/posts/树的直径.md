---
title: 树的直径
date: 2022-07-15 12:14:05
tags:
- 树的直径
- 知识点笔记
categpries: 
- 模版
- 图论
- 树的直径
---

## 树的直径

### 算法一 两次dfs
一次dfs求该点的最长距离，第二次从上一个最长路径的另一个端点再一次求解最长路径

### 算法二 树形dp
任意选择一个点u，以u为根节点找其的最长路径和最短路径。这两条路径就构造出我们的树的直径。

### CODE
```C++
#include <vector>
#include <cstring>
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <map>

#define ll long long
#define pii pair<int,int>
#define x first
#define y second

using namespace std;

const int N = 20010;

int h[N],e[N],ne[N],w[N],idx;
int n,m;
int ans;

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

int dfs(int u, int father)  // 返回的是以u为根节点的的树的最长路
{
    // 我们每次枚举都是以u这个节点为最高点(根节点）找其作为根的树的直径
    int dist = 0; //从这个点开始往下找的最长路径
    int d1 = 0, d2 = 0; // d1为最长路径 d2为次长路径

    for(int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if(j == father) continue;
        int d = dfs(j,u) + w[i];
        dist = max(dist,d);
        // 用其子节点的子树的树的直径更新 父节点作为根节点的树的直径
        if(d >= d1) d2 = d1, d1 = d;
        else if(d > d2) d2 = d;
    }
    ans = max(ans, d1 + d2);
    return dist;
}

int main()
{
    cin >> n;
    m = n-1;
    memset(h, -1 ,sizeof h);
    for(int i = 0; i < m; i ++)
    {
        int a, b,c;
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
        add(b,a,c);
    }

    dfs(1,-1);
    cout << ans << endl;
    return 0;
}
```
