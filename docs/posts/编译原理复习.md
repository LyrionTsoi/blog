---
title: 编译原理复习
date: 2023-06-13 11:01:27
tags:
---


## 第四章 语法制导

4.3 为文法

```text
 S -> (L) | a
 L -> L,S | S
```

(a) 写一个语法制导定义，它输出括号的对数。

(b)写一个文法制导定义，它输出括号嵌套的最大深度。

答：

(a)首先要使用拓广文法，然后利用递归的定义来制定语法制导定义。
$$
\begin{aligned}
&S' \to S&  \quad \quad \quad \quad    &print(S.num)& \\
&S \to (L)& \quad \quad \quad \quad \quad &S.num = L.num + 1& \\
&S \to a&\quad \quad \quad \quad \quad &S.num = 0 \\
&L \to L_1,S&\quad \quad \quad \quad \quad    &L.num = L_1.num + S.num \\
&L \to S&\quad \quad \quad \quad \quad     &L.num = S.num \\
\end{aligned}
$$
具体来说我们输出的答案的地方是 $print(S.num)$,那借用递归调用的思想，首先我们到最低层 $L \to S$,明显的知道$L.num = S.num$，然后到了倒数第二个产生式知,如果要计算括号的数目就要讲产生式右部的所有括号加起来即 $L.num = L_1.num + S.num$.那对于 $S \to a$的表达式得来说的就是 $S$退出来一个终结符，很明显知道一个终结符一定是不存在括号的所以就将$0$值赋予到$S$上，对于最后一条表达式的来说 $S \to (L)$,因为L的外部还用一个括号，所以还需要在$L.num$的基础上加上$1$

(b)
$$
\left.               
  \begin{array}{l}   % 左对齐
    S'\rightarrow S\textbf{n} && print(S.val) \\
    S\rightarrow (L) && S.val = L.val + 1 \\
    S\rightarrow a && S.val = 0 \\
    S\rightarrow L,\space S_1 && {L.val = max(L.val,S_1.val)} \\
    L\rightarrow S && L.val = S.val \\
  \end{array}
\right.
$$
4.13

**语句的文法如下：**
$$
S →\textbf{id}:=E\space |\space  \textbf{if}\space E \space \textbf{then}\space S \space |\space \textbf{while} \space E\space \textbf{do}\space S \space |\space \textbf{begin}\space S;S\space \textbf{end} \space |\space  \textbf{break}
$$
**写一个翻译方案，其语义动作的作用是：若发现break不是出现在循环语句中，及时报告错误。**
$$
\left.               
	\begin{array}{l}   % 左对齐
        S'\rightarrow &&& \{S.loop=false\} \\
        &S \\
        S\rightarrow & \textbf{id}:=E \\
        S\rightarrow & \textbf{if}\space E \space \textbf{then} && \{S_1.loop = S.loop\} \\
        & S_1 \\
        S\rightarrow &\textbf{while} \space E\space \textbf{do} && \{S_1.loop=true\} \\
        & S_1 \\
        S\rightarrow & \textbf{begin} && \{S_1.loop = S.loop\}\\
        & S_1; && \{S_2.loop=S.loop\}\\
        & S_2\space \textbf{end} \\
        S\rightarrow &\textbf{break} && \{if \space not \space S.loop \space then \space print('error')\}
	\end{array}
\right.
$$


4.14 

**程序的文法如下：**
$$
P→D \\
D→D;D \space | \space \textbf{id}:T \space | \space  \textbf{proc} \space \textbf{id};D;S
$$
**（a）写一个语法制导定义，打印该程序一共声明了多少个$\textbf{id}$。**

$s$是$D$的综合属性，用于$D$中 $\textbf{id}$ 的个数。
$$
\left.               
	\begin{array}{l}   % 左对齐
		P\rightarrow D && print(D.s) \\
		D\rightarrow D_1;D_2 && print(D.s = D_1.s+D_2.s) \\
		D\rightarrow \textbf{id} : T && D.s = 1 \\
		D\rightarrow \textbf{proc} \space \textbf{id};D_1;S && D.s = D_1.s + 1 \\
	\end{array}
\right.
$$
**（b）写一个翻译方案，打印该程序每个变量$\textbf{id}$的嵌套深度。**

$i$为$D$的继承属性，用于计算$D$所在的程序嵌套深度。
$$
\left.               
	\begin{array}{l}   % 左对齐
		P\rightarrow &&& \{D.i = 1\} \\
		& D \\
		D\rightarrow &&& \{D_1.i = D.i\} \\
        & D_1; && \{D_2.i = D.i\} \\
        & D_2 \\
		D\rightarrow & \textbf{id} : T && \{print(D.i)\} \\
		D\rightarrow & \textbf{proc} \space \textbf{id}; && \{D_1.i = D.i + 1\} \\
		& D_1;S\\
	\end{array}
\right.
$$


## 第五章 类型检查

5.4

（a) 
$$
array(100,pointer(real))
$$
(b)
$$
array(10,array(20,type))
$$
(c)
$$
linteger \to pointer(linteger) \to record((x:integer)*(ch:char))
$$
5.6
$$
\left.               
	\begin{array}{l}   % 左对齐
		P \to D;E \\ 
		D \to D;D \\
		D \to id : T && {addtype(id,entry,T.type)}\\
		T \to list\space of \space T_1 && {T.type = list(T.type)} \\ 
		T \to char && {T.type = char} \\ 
		T \to integer && {T.type = int} \\ 
		E \to (L) && {E.type = char} \\
		E \to literal && {E.type = char} \\ 
		E \to num && {E.type = int} \\
		E \to id && {E.type = lookup(id,entry)}\\
		L \to E && {L.type = E.type}\\
		L \to E,L_1 && {L.type = if\space L_1.type == E.type \space then \space E.type \space else \space type = error}\\
	\end{array}
\right.
$$
