---
title: POJ-1321 棋盘问题
date: 2022-10-15 20:07:12
tags:
- 搜索
- DFS
categories:
- POJ
- 搜索
---

## [POJ-1321 棋盘问题](https://vjudge.net/problem/POJ-1321)
在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。
Input
输入含有多组测试数据。
每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n <= 8 , k <= n
当为-1 -1时表示输入结束。
随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。
Output
对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C<2^31）。
Sample
Input
```
2 1
#.
.#
4 4
...#
..#.
.#..
#...
-1 -1
```
Output
```
2
1
```

## 题解
本题有棋子的个数限制，所以有可能会出现棋子不足/棋子过量的情况，所以不能想八皇后问题，第一行一定会摆棋子。

## CODE
```C++
#include <vector>
#include <cstring>
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <map>
#include<cmath>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 10;

int n, m;
ll res;
char g[N][N];
bool st[N]; // 记录每一列的状况

void dfs(int x, int cnt)
{
    if(x >= n)
    {
        if(cnt == m) res ++;
        return;
    }

    for(int i = 0; i < n; i ++)
    {
        if(g[x][i] == '#' && !st[i])
        {
            st[i] = true;
            dfs(x + 1,cnt + 1);
            st[i] = false;
        }
    }

    dfs(x + 1, cnt);
}

int main()
{
    while(cin >> n >> m, ~n)
    {
        for(int i = 0; i < n; i ++)
            scanf("%s",g[i]);

        res = 0;
        
        dfs(0, 0);

        cout << res << endl;
    }

    return 0;
}
```