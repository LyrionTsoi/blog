---
title: 编译原理期末复习
date: 2023-06-07 21:32:57
tags:
---

# 第二章 词法分析

**什么是正规式？**

正规式是一种描述正则语言的表达式，它由终结符、或运算符、连接运算符和闭包运算符组成，可以用来表示一个字符串集合。
$$
\left.               
	\begin{array}{l}   % 左对齐
	(a) (r) | (s) \\
  (b) (r)*	
	\end{array}
\right.
$$
**什么是产生式？**

产生式是一种表示文法规则的形式，它由一个左部和一个右部组成，左部是一个非终结符，右部是一个由终结符和非终结符组成的字符串。产生式的含义是，左部可以被右部替换。
$$
A \to id | B
$$
**什么是文法？**

文法是一种描述语言的语法结构的形式规则，它由一个非终结符集合、一个终结符集合、一个起始符和一组产生式组成。文法可以分为四种类型：0型、1型、2型和3型，根据对产生式的限制不同，描述能力也不同。

**什么是NFA？**

NFA指的是不确定有限自动机。表示状态转换的。正常的特征是：包含了**空转化**，同时可能有一个输出多个可以转换成多个状态的情况。即它的转移函数可以给出多个可能的下一个状态，或者可以在不消耗输入符号的情况下进行状态转换（ε-转移）。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211102279.png)

**什么是DFA？**

DFA是确定的有限状态自动机，它的转移函数只能给出一个唯一的下一个状态，并且不能有空串转移。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211103561.png)

## 正规式构造NFA

或关系的构造$R = R_1 | R_2$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211113868.png)

与关系的构造 $R = R_1* R_2$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211114853.png)

闭包关系 $R = R_1^*$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211115071.png)

括号 $R= (R_1)$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211115184.png)

**例题**

**用算法 2.4 为下列正规式构造不确定有限自动机，给出它们处理输入串 $ababbab$ 的状态转化序列**

1. $(\space\space a\space\space|\space\space b\space\space)\space^*$

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211604683.png)

2. $(\space\space a\space^*\space\space|\space\space b\space^*\space\space)\space^*$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211153145.png)

3. ⚠️$(\ a\ | \ c\ )^*\ a\ b^*\ c$

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211600008.png)

4. $(\space\space(\space\space \varepsilon\space\space |\space\space a\space\space)\space\space b\space^*\space\space)\space^*$

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211541296.png)

5. $(\space\space a \space\space | \space\space b\space\space) \space^*\space\space a\space\space b\space\space b\space\space(\space\space a \space\space | \space\space b \space\space)\space^*$

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211554942.png)

## NFA转化为DFA

**子集构造法**

**例题： **

一、 $(\space\space(\space\space \varepsilon\space\space |\space\space a\space\space)\space\space b\space^*\space\space)\space^*$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211651069.png)

编号10为终态（上面图没有画出）

 

| 状态                            | a                                 | b                                 |
| :------------------------------ | --------------------------------- | --------------------------------- |
| $S_{d0}=\{S,1,2,3,4,6,7,9,10\}$ | $S_{d1}=\{S,1,2,3,4,5,6,7,9,10\}$ | $S_{d2}=\{S,1,2,3,4,6,7,8,9,10\}$ |
| $S_{d1}$                        | $S_{d1}$                          | $S_{d2}$                          |
| $S_{d2}$                        | $S_{d1}$                          | $S_{d2}$                          |

我们终态编号为10的结点，所有的最后的状态集中都包含了编号10的结点。

令 $A\ =\ S_{d0}$, $B\ =\ S_{d1}$, $C\ =\ S_{d2}$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211707991.png)

二、$(\ a\ | \ c\ )^*\ a\ b^*\ c$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306211708603.png)

| 状态                         | a                                   | b                               | c                                 |
| ---------------------------- | ----------------------------------- | ------------------------------- | --------------------------------- |
| $S_{d0} = \{ S,1,2,4,7   \}$ | $S_{d1}=\{1,2,3,4,6,7,8,9,11,12 \}$ | $S_{d2}=\{2,4,7\}$              | $S_{d3}=\{1,2,4,5,6,7\}$          |
| $S_{d1}$                     | $S_{d4}=\{1,2,3,4,6,7,8,9,11\}$     | $S_{d5}=\{1,2,4,6,7,9,10,11 \}$ | $S_{d6}=\{1,2,4,5,6,7,9,11,12 \}$ |
| $S_{d2}$                     | $S_{d4}=\{1,2,3,4,6,7,8,9,11\}$     | 走不通$S=\{\varepsilon\}$       | $S_{d3}=\{1,2,4,5,6,7\}$          |
| $S_{d3}$                     | $S_{d4}=\{1,2,3,4,6,7,8,9,11\}$     | $S_{d7}=\{1,2,4,6,7\}$          | $S_{d3}=\{1,2,4,5,6,7\}$          |
| $S_{d4}$                     | $S_{d8}=\{1,2,3,4,5,6,7,8,9,11\}$   | $S_{d5}=\{1,2,4,6,7,9,10,11\}$  | $S_{d6}=\{1,2,4,5,6,7,9,11,12\}$  |
| $S_{d5}$                     | $S_{d4}=\{1,2,3,4,6,7,8,9,11\}$     | $S_{d9}=\{1,2,4,7,9,10,11\}$    | $S_{d6}=\{1,2,4,5,6,7,9,11,12\}$  |
| $S_{d6}$                     | $S_{d4}=\{1,2,3,4,6,7,8,9,11\}$     | $S_{d5}=\{1,2,4,6,7,9,10,11\}$  | $S_{d10}=\{1,2,4,5,6,7,12\}$      |
| $S_{d7}$                     | $S_{d4}=\{1,2,3,4,6,7,8,9,11\}$     | $S_{d11}=\{1,2,4,7\}$           | $S_{d3}=\{1,2,4,5,6,7\}$          |
| $S_{d8}$                     |                                     |                                 |                                   |
| $S_{d}$                      |                                     |                                 |                                   |
| $S_{d}$                      |                                     |                                 |                                   |

⚠️这里有一个小技巧就 $S_{d1}$走 $c$ 来举例

首先我们一直都是基于原集合元素进行状态的变化的。$S_{d1}=\{1,2,3,4,6,7,8,9,11,12 \}$

$1$看能否走$c$或者走 $\varepsilon$，发现可以走$\varepsilon$,得到下一个结点为 $2,4$，发现这两个状态在我们原集合状态当中且没有被遍历，那么我们就不需要再继续走下去。

然后再对原集合内的 $2$节点进行走$c$或者走 $\varepsilon$，发现走不通。

3节点看能否走$c$或者走 $\varepsilon$，发现可以走$\varepsilon$,得到下一个结点为 $6$，发现这个状态在我们原集合状态当中且没有被遍历，那么我们就不需要再继续走下去。

4节点看能否走$c$或者走 $\varepsilon$，发现可以走 $c$，得到下一个结点为5，发现这个编号的节点我们集合当中没有，那么就继续对5节点继续走$\varepsilon$，下一步就走到6号节点了，6节点在原集合当中且没有被遍历。

其他节点同理

这里的状态集太多了，有时间续上。。。

## DFA化简

和NFA转化为DFA的过程很像，就是将终态和中间态划分。

**例题**

1. $(\space\space(\space\space \varepsilon\space\space |\space\space a\space\space)\space\space b\space^*\space\space)\space^*$

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306212043498.png)

   简化DFA首先要对NFA转换成DFA

   上面我们已经将NFA化为DFA了，所以我们现在需要做时化简作用。

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306212044172.png)

可以很明想看出来这里只能分成一个类别：终态类集。所以在这里就一定是最简的了。

所以就将这三个终结类合成一个类别就可以了。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306212145415.png)

2. $\space\space(\space\space a\space\space | \space\space b\space\space)\space^*\space\space a\space\space (\space\space a \space\space |\space\space b\space\space)$

   对应的 NFA 如下：

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306212122635.png)

   对应的转换表如下：

   $A=\{0,1,2,4,7\}$

   $B=\{1,2,3,4,6,7,8,9,11\}$

   $C=\{1,2,4,5,6,7\}$

   $D = \{1,2,3,4,6,7,8,9,10,11,13,14\}$

   $E=\{1,2,4,5,6,7,12,13,14\}$

   <table style="width:500px;" align="center">
       <tr align = 'center'>
           <td rowspan = '2'>状态</td>
           <td colspan = '2'>输入符号</td>
       </tr>
       <tr align = 'center'>
           <td>a</td>
           <td>b</td>
       </tr>
       <tr align = 'center'>
       	<td>A</td>
           <td>B</td>
           <td>C</td>
       </tr>
       <tr align = 'center'>
       	<td>B</td>
           <td>D</td>
           <td>E</td>
       </tr>
       <tr align = 'center'>
       	<td>C</td>
           <td>B</td>
           <td>C</td>
       </tr>
       <tr align = 'center'>
       	<td>D</td>
           <td>D</td>
           <td>E</td>
       </tr>
       <tr align = 'center'>
       	<td>E</td>
           <td>B</td>
        	<td>C</td>
       </tr>
   </table>


   对应的 DFA 如下：

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306212129810.png)

进行DFA化简

分别为两个类型的集合可接受状态$\{D,E\}$与非可接受状态 $\{A,B,C\}$

先对非可接受子集进行划分

$\{A,B,C\}$  = $\{A，C\}、\{B\}$，因为A和C最后还是回到$\{A,B,C\}$这个子集当中，但是 $\{B\}$通过a转换到了 $\{D\}$当中，所以需要划分出去。**只要不在同一个子集的话，就需要对应划分开**。⚠️**这里的子集只指的是上一次划分后的子集类**

然后再继续划分 $\{A，C\}$，发现无论是通过a最后都转移到了 $\{B\}$上，还是通过b最后都转移到 $\{C\}$上

所以最后非可接受状态划分为了 $\{A,C\}$, $\{B\}$

然后再接着划分 $\{D,E\}$,通过转移$a$, $E$最后转移到了$\{B\}$，$D$最后转移回了自己，所以$D$与$E$应该要划分开

# 第三章 语法分析

## LL(1)文法

**例题**

一、 **考虑文法**
$$
S\rightarrow aSbS\space|\space bSaS \space | \space \varepsilon
$$
**(a) 为句子 $abab$ 构造两个不同的最左推导，以此说明该文法是二义的。**
$$
\begin{aligned}
  S &\to aSbS \\
  &\to abSaSbS \\
  &\to abaSbS \\
  &\to ababS \\
  &\to abab
\end{aligned}
$$

$$
\begin{aligned}
  S &\to aSbS \\
  &\to \textcolor{red}{abS} \\
  &\to abaSbS \\
  &\to ababS \\
  &\to abab
\end{aligned}
$$

（b） 为 abab 构造对应的最右推导。
$$
\begin{aligned}
  S &\to aSbS \\
  &\to aSbaSbS \\
  &\to aSbaSb \\
  &\to aSbab \\
  &\to abab
\end{aligned}
$$
（c） 为 abab 构造对应的分析树。

最左推导树

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306212229964.png)

最右推导树也差不多就不赘述

二、 书上3.8

(a) 消除习题 3.1 文法的左递归。
$$
S \rightarrow (L)\space | \space a\\
L\rightarrow L, S \space | \space S
$$
(b)  为(a)的文法构造预测分析器。

先进行拓展文法
$$
\begin{aligned}
&S \rightarrow (L)\space \\
&S \rightarrow a \\
&L \to S\ L_1 \\
&L_1 \to ,\ S\ L_1 | \varepsilon
\end{aligned}
$$
(b)预测分析器也就是说自顶向下文法。

自上而下的步骤：1. 利用`First`和`Follow`构建分析表 2. 判断是否为 LL(1)文法

判断`LL(1)`文法：不含左因子，不含二义性（一个句子只能对应一种推导方式），不含左递归

更直接的判断
$$
\begin{aligned}
&A \to \alpha | \beta \\
&\beta ≠ \varepsilon, first(\alpha) \cap first(\beta)= \varnothing \\
&\beta = \varepsilon, first(\alpha) \cap follow(A)= \varnothing
\end{aligned}
$$
构造`first`集
$$
\begin{aligned}
&first(S) = \{\ (\ , \ a \ \} \\ 
&first(L) = \{\ first(S)\  \}\ = \ \{\ (\ , \ a \ \} \\
&firts(L_1) = \{\ ','\ ,\ \varepsilon \}
\end{aligned}
$$
`first`集的构造

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306221218391.png)

要注意的一点是如何 $X_1$的`first`集有空集的话就必须继续往下面的 $X_2$看

构造 `follow`集
$$
\begin{aligned}
follow(S)\ &=\ \{\  \{first(L_1) - \varepsilon\}  + follow(L)\ +\ follow(L_1) \}\ =\ \{\ ','\ ,\ )\ , \$\ \} \\
follow(L)\ &=\ \{ \ ) \ \} \\ 
follow(L_1)\ &=\ \{\ follow(L)\ \} = \{\ )\ \} \\
\end{aligned}
$$
![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306221222005.png)

**构造分析表**

| 非终结符 | (                                                            | )                                                            | a                 | ,                   | $    |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------- | ------------------- | ---- |
| S        | $S \rightarrow (L)\space$(左括号在S的`first`集当中，所以把通过左括号进行的转态变化的产生式加入) |                                                              | $S \rightarrow a$ |                     |      |
| L        | $L \to S\ L_1$（因为产生式的右部第一个字符是非终结符S，但是S的first集中有左括号） |                                                              | $L \to S\ L_1$    |                     |      |
| $L_1$    |                                                              | $L_1 = \varepsilon$（因为 $L_1$的first集里面有空，所以需要把 $L_1$的follow集所有的元素都推出到当前这里的产生式) |                   | $L_1 \to ,\ S\ L_1$ |      |

判断是否为`LL(1)`文法
$$
\begin{aligned}
&L_1 \to ,\ S\ L_1 | \varepsilon \\ 
&\beta = \varepsilon, first(,\ S\ L_1) = ',',follow(L_1) = ),first(,\ S\ L_1) \cap follow(L_1) = \varnothing 
\end{aligned}
$$
所以是`LL(1)`文法

例题二、
$$
\begin{aligned}
S &\to \ a\ A\ b\ |\ c\ A\ d \\
A &\to \ a\ c\ |\ \varepsilon
\end{aligned}
$$
构造上面的`first`和`follow`集

拓广文法
$$
\begin{aligned}
\begin{aligned}
S &\to \ a\ A\ b\ \\
S &\to \ c\ A\ d \\
A &\to \ a\ c\ \\
A &\to \ \varepsilon
\end{aligned}
\end{aligned}
$$
`first`集的建立
$$
\begin{aligned}
first(S) &= \{\ a\ ,\ c\ \} \\ 
first(A) &= \{\ a,\ \varepsilon\}
\end{aligned}
$$
`follow`集建立
$$
\begin{aligned}
follow(S) &= \{\$\} \\
follow(A) &= \{b,d\}
\end{aligned}
$$

## LR(0)文法

步骤：拓广文法 $\to $ 列项目 $\to $ 项目集规范族（DFA图）$\to $ 分析表

例题：源自于课件

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306221543569.png)

首先需要拓广文法
$$
\begin{aligned}
E' &\to E \\
E &\to E + T \\
E &\to T \\ 
T &\to T * F\\
T &\to F\\
F &\to (E) \\
F &\to id
\end{aligned}
$$
这里的列项目可以和DFD图同时一块构建

⚠️初始项目的建立

**不能把点全部加入到产生式的前面**

I0是要通过S' ->S进行求闭包的，因为现在点在S前，S是非终结符，所以要把S的产生式都加上，然后再把新加上的产生依次循环上面两个步骤

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306221557191.png)

上面这个状态太多了。。。

例题二、
$$
\begin{aligned}
S &\to \ a\ A\ b\ |\ c\ A\ d \\
A &\to \ a\ c\ |\ \varepsilon
\end{aligned}
$$
为上面这个文法构造LR（0）文法

拓广文法
$$
\begin{aligned}
\begin{aligned}
S' &\to S \\
S &\to \ a\ A\ b\ \\
S &\to \ c\ A\ d \\
A &\to \ a\ c\ \\
A &\to \ \varepsilon
\end{aligned}
\end{aligned}
$$
![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306221730875.jpg)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306221735598.jpeg)

`first`集的建立
$$
\begin{aligned}
first(S) &= \{\ a\ ,\ c\ \} \\ 
first(A) &= \{\ a,\ \varepsilon\}
\end{aligned}
$$
`follow`集建立
$$
\begin{aligned}
follow(S) &= \{\$\} \\
follow(A) &= \{b,d\}
\end{aligned}
$$
![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306221808467.jpeg)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306222120639.png)

## SLR（1）文法

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306222044159.jpeg)

这里和`LR(0)`的唯一区别是`LR(0)`当做规约的时候是把整行都做规约，而`SLR(0)`仅对`follow`集的元素添加产生式

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306222120826.png)



# 第四章 语法制导

## 属性

继承属性：自下而上的传递信息。继承属性的值是由其父亲节点的值和兄弟节点的值都推导出来的

综合属性：自上而下的传递信息。通常综合属性的值都是由其子节点的值进行传递得到。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306231524230.jpg)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306231524636.jpg)

## **依赖图**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306231557907.jpg)

数据的流向，简单来讲就是从赋值者指向被赋值者。

## S-属性

也就是语法书内的所有的属性都是综合属性。这个语法树的属性值是最好判断的，直接自底向下去讲值传递到最顶点即可。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306231604919.png)

## L-属性

不那么严谨来讲就是一个语法分树当中即包含了综合属性又包含继承属性。

严谨一点讲

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306231601815.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306231604958.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306231613563.jpeg)

首先综合属性的传递的过程所有写出，直到写不出，然后再计算继承属性即可。

## 语法翻译

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306232030488.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306232109616.jpeg)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306232109723.jpeg)

# 简答题

## 编译器和解释器的异同

|              | 解释器                   | 编译器                       |
| ------------ | ------------------------ | ---------------------------- |
| 程序执行步骤 | 在程序执行时转换         | 在程序执行之前转换           |
| 输入         | 每次仅对一行代码进行转换 | 每次对整个程序代码进行转换   |
| 输出         | 不生成中间代码           | 生成中间代码                 |
| 工作区别     | 编译和执行同时进行       | 编译在执行之前完成           |
| 存储         | 不保存任何的机器代码     | 存储编译后的机器代码在机器上 |
| 速度         | 慢                       | 快                           |

## LR(1)与LL(1)的对比

|                      | LR(1)                                                        | LL(1)                                                        |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 建立分析树的方式     | 自下而上                                                     | 自上而下（所以也叫预测分析)                                  |
| 规约还是推导         | 规范规约                                                     | 最左推导                                                     |
| 决定产生式使用的时机 | 当看见产生式右部的所有的终结符后，才决定使用哪一个产生式进行规约 | 当看见产生式右部的第一个终结符后，就要决定采用那个一个产生式进行推导 |
| 对文法的显性限制     | 对文法没有限制                                               | 1.不含左递归  2.不含公共左因子                               |
| 分析表对比           | 采用转态+ 文法符号的形式，分析表较大                         | 采用终结符+非终结符的形式，分析符较小                        |
| 分析栈对比           | 状态栈，通常状态比文法符号包含更多的信息                     | 文法符号栈                                                   |
| 确定句柄             | 根据栈顶 状态和下一个符号便可以确定句柄和规约所用的产生式    | 无句柄概念                                                   |
| 语法错误             | 不会将出错点后的符号移入分析栈                               | 不会读过出错点而不报错                                       |

## 影响存储分配策略的语言特征

1. 过程能否被调用
2. 当控制从过程活动返回时，局部变量的值是否要保留
3. 过程能否访问非局部变量
4. 过程调用的参数传递方式
5. 过程能否作为参数被传递
6. 过程能否作为结果只被传递
7. 存储块能否在程序控制下动态分配
8. 存储块是否显式释放

## NFA 与 DFA的比较

NFA叫做不确定有限自动机，即表示当有一个输入可以产生多个输出，这种就出现二义性的问题。因此自动机执行大量的回溯，从而会浪费许多的计算机资源，（也因为回溯的问题导致出错点的位置不好确定）。而DFA不同，DFA是确定的有限自动机，即在输出之后就会有对应的一个确定的输出(隐射的方式是一种单值函数的方式)，不存在回溯问题，所以不会浪费计算机资源。

## 正规式的优缺点

**优点**：

1. 正规式的词法规则比较简答，其描述也相对于比较简洁且易于理解
2. 正规式构造的词法分析器相对于其他文法来说会更加的高效

**缺点：**

词法规则过于简单，不能处理复杂的问题所以能力不强

## 文法的优缺点

**优点**

1. 给出精确且易于理解的语法定义
2. 自动生成高效词法分析器
3. 可以给语言定义出层次结构
4. 便于语言的修改

**缺点**
不能描述语言中上下文有关的语法特征

## 分离词法分析器理由

**使用正规式定义词法**

1. 因为词法规则比较简单，所以不需要功能性比较强且复杂的上下文无关文法来定义
2. 对于词法记号来说，正规式描述简洁且易于理解
3. 正规式构造出的词法分析器效率比较高

**软件工程角度**

1. 简化设计
2. 编译器效率提高
3. 编译器的可移植性更强
4. 便于编译器前端的模块划分

**如果把词法分析器与语法分析器合并在一起**

这样就需要将语言的注释与空白的规则写入到文法当中这样就会使得文法的复杂性大大上升。要自己处理注解和空白的分析器，比使用删除掉的注释和空白词法分析器要复杂的多。

## 编译器分为哪几个阶段？为什么语法分析是其中的核心？

大体上分为前端和后端，分别为分析和综合。具体7个阶段，词法分析，语法分析，语义分析，中间代码生成，独立机器的代码优化器，代码生成，依赖机器的代码优化器。

语法分析：读取词法分析输出词法记号流。检查词法记号流是否符合语法则，并依据规则体现出语言构造的层次性，用各记号的第一元建立成一颗树形的中间表示，这个中间表示用抽象的语法方式描绘了该记号流的语法情况

## 为什么不用上下文无关文法做词法分析？

1. 因为词法规则比较简单，仅使用正规式来表示足以满足需求。而不需要使用功能性更强的上下文无关文法。
2. 对于词法记号来说，正规式的表达描述会更加简洁且易于理解。
3. 正规式产生的词法分析器会更加高效。

## 边分析边翻译的方式能否适用于继承属性的计算？

不一定能。

1. 若翻译在分析的同时进行的话，属性的计算次序一定受其分析方法建立的分析树节点的次数限制
2. 分析树的节点建立是自左向右建立
3. 如果属性信息流动也是自左向右进行流动的话，那么属性的分析和翻译就有可能同时进行

## 代码生成器设计中需考虑哪些问题？

1. 程序语言的选择，一共有三种程序语言可以选择，分别为绝对机器语言程序，可重定位机器语言程序以及汇编语言程序。
   1. 产生绝对机器语言程序的优点在于：可以存放在固定的内存地址上，并且可以直接执行的程序
   2. 可重定位语言程序：子程序可以分别编译，并且可以存放在任意的内存地址上面，目标模块可以利用先前已经编译好的程序模块
   3. 汇编语言程序：产生符号指令并可以利用编译器的宏机制自动产生代码，代码的生成变得更加容易，但是代价就是需要执行在代码生成后的代码汇编工序
2. 指令的选择。代码生成器必须把中间表示程序映射到目标机器上可执行的指令序列。这个映射的复杂性取决于中间表示的层次，指令集架构的性质以及所生成代码的质量等问题。
3. 寄存器分配可以分为两个子问题
   1. 寄存器分配：为程序各点选择驻留在哪一个寄存器上
   2. 寄存器指派：为需要驻留在寄存器上的变量选择一个寄存器保存其变量值。
4. 计算次序的选择。计算次序的选择会影响目标代码的效率。

## 请简述使用正规式构造词法分析器的流程

1. 正规式转化NFA 
2. NFA转化成DFA
3. DFA化简
4. DFA构建词法分析器

## 简述 SLR（1）和 LR（1）文法的定义

都是LR分法：如果能为它构造出所有条目都唯一的LR分析表即为LR文法。直观上说，当句柄出现在分析栈的栈顶的时候，如果自左向右进行扫描的移进-规约分析器能及时识别它，那么文法一定是LR文法。

SLR（1）是最简的LR（1），它不带向前搜索符，为了解决LR(0)中移进-规约冲突和规约-规约冲突。

通常如果一个项目为
$$
A \to b . \\ 
B \to a.+A
$$
这里会有一个移进-规约冲突，如果点后面的终结符（这里是+)与 $Follow(A)$没有交集的话就是SLR（1）文法

LR（1）文法：重新定义项目，包含一个向前搜索符，表示为 $S \to a.\beta,b$, $S \to a.\beta$是产生式，b是终结符或 $.

# 名词解释

**编译器：**是一种翻译器，将高级语言转化为低级语言程序的软件

**翻译器：**是一种能够完成从一种语言到另一种语言的保语言变换的软件

**解释器：** 是一种能把高级语言一行一行直接转译运行的程序

**编译器概述**：

**阶段分组**为：前端（分析）与后端（综合）

词法分析器 、 语法分析器、 语义分析器 、 中间代码生成器、独立于机器的代码优化器、代码生成器、依赖于机器的代码优化器

**正规式：**按照一组定义规则，由比较简单的正规式构成，每个正规式r表示一个语言 $L(r)$

**有限自动机：**把正规式翻译成识别器的有限自动机的转换图

**上下文无关文法：**是四元组 $(V_T, V_n, S, P)$,$V_T$终结符，$V_n$非终结符， $S$开始符号（非终结符中的其中一个）， $P$产生式集合 

**推导：**把产生式看成重写规则，产生式左部的非终结符使用产生式右部的串来代替

**过程：**过程和函数这样的程序单元称作过程

**过程的一次活动：**程序运行时过程的一次执行称之为过程的一次货

**活动记录**：过程的每次活动都需要可执行代码和存放所需的数据的存储空间，以及保存局部数据的通常需要一块连续的存储空间。

**生存期**：指的是过程体从开始执行到执行结束的时间，包括消耗在有过程p调用其他过程所需要的时间等

**作用域**：声明起作用的程序部分

**环境**：表示名字映射到存储单元的函数

**状态**：存储单元映射到它所保存值的函数

**编译器**：编译器是一种翻译器，将高级语言转化成低级语言的程序

**句柄：**指的是句型中和一个产生式右部匹配的子串，并且可以把他规约岛该产生式左部的非终结符，代表的最右推导的逆过程。

**L属性定义：**指的是使用了综合属性和受到限制的继承属性，具体来讲加入一个产生式为 $ A \to x_1x_2...x_n$ ,$x_n$对应的继承属性来自取前$n-1$个兄弟属性值和产生式右部A的属性值

**S属性定义：**仅使用了综合属性的语法制导定义

**良行为程序：**指的是程序不会出现城程序出错了但是没有进行出错捕获报告的情况。

**三地址代码：**例如 $x = y\ op\ z$, $x$表示名字，$y$表示常数，$z$表示编译器产生的临时变量

**活前缀：**是右句型对应的前缀，该前缀不超过右句型的最右句柄的右端

**LR文法：**一个文法如果能为他构造出来的所有条目都唯一的LR分析表即为LR文法。

**定型断言与定型规则：**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202306242253858.png)

# 开放题 对比编译原理和自然语言处理

编译原理主要有7个步骤，自然语言处理包含了分词与词性标注、句法分析与语义角色标注

自然语言处理基于重定义模型和语料库，处理能力更大，可能会有歧义；编译原理基于规则和形式化语言描述

一、词法分析

编译过程和自然语言处理过程的分词和词性标注相似，词法分析与中文词性标注处理的对象分别为代码段和中文句子。两者都需要对待处理序列进行预处理，区别在于前者会去掉代码段中的注释与空白，而后者会去除非中文字和统计高频字。在算法层面，前者采用的算法相对比较简单，基于状态转换图的识别算法；后者采用的是算法较多且相对比较复杂，大部分基于字符串（规则）的最大匹配算法。

二、语法分析

编译过程的语法分析基于词法分析产生的词法记号流，进一步分析的其语法是否符合语言规则，主要流行的算法是自顶向下和自底向上的语法树生成和分析算法。

自然语言处理的句法分析同样是基于分词产生的词单元。进步分析该句话的各部分之间的依赖关系，一定程度上可以看作为语法分析的更深层次处理。语法分析进用作分析语句是否成立，而句法分析不仅可以判断语句是否可以成立，并且可以分析语句中的主谓关系，动宾关系。其中间步骤同样也采用了树与图的算法，目前比较流行的算法为CFG分析算法。

三、语义分析

编译过程中的语义分析用来判断某段代码是否符合既定规则。如+运算的左右操作符要求都为整型类别才可以进行加法运算。一般来说语义分析采用了递归下降达到生成之间代码的目的，递归下降算法将语句结束符为节点，递归逐段判断代码是否符合既定规则，最后输出结果又许多表达方法如三地址四地址，逆波兰、

自然语言处理的语义角色标注用来标注一句话中语义信息的角色，角色的不同组合，相同词在不同话中语义可能不同。语义角色标注任务可以判断相同词在不同语义下的不同语句中的含义。一 种含义， 需用到哪些“角色”， 是编译语义分析的深层理解。目前公认的效果 较好的模型是 LSGN.

