---
title: DS考研复习
date: 2023-03-28 22:05:36
tags:
- 数据结构
- 考研
categories:
- 考研
- 专业课
- 数据结构
---

# 第二章 线性表

## 顺序表

## 链表

### 单链表

带头节点的头插法

```

```

不带头节点的头插法

```c++
/*不带头结点的单链表的创建(头插法)*/
void LinkCreate(Node *&L) {
	int a=0;
	cout << "请输入数据" << endl;
	cin >> a;
	while (a!=9999) { //数据为9999时，停止输入
		Node *p;
		p = (Node*)malloc(sizeof(Node));
		p->data = a;
		p->next = L;
		L = p; // 每次插入一个节点都让头指针指向新的节点（也是和带头节点的最大区别）
		cin >> a; //连续输入数据
	}
}

```

带头节点的尾插法

```

```

不带头节点的尾插法

```c++
//尾插法
void LinkCreate(LinkNode *&L) {
	int a = 0;
	cout << "请输入数据" << endl;
	cin >> a;
	Node *r;
  L = NULL; // 先让L指向空节点
	r = L; // r是尾指针
  // 9999是结束的标志
	while (a != 9999) {
		Node *p;
		p = (Node*)malloc(sizeof(Node));
		p->data = a;
		p->next = NULL; // 最后一个节点next指针一定指向的是空节点
    // 做一步第一个节点的特判
		if (L==NULL) {
			L = p;
			r = L;
		}
		else {
			r->next = p;
			r = p;
		}
		cin >> a;
	}
}
```

## 王道第二章大题

### 2.2.3 顺序表

08.![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304052159958.png)

```c++
// 将数组内部的两个顺序表交换顺序
// 有一种比较暴力的做法（用空间换时间）
void change(int data[]){
    int p[N];
    int loc = 0; // loc 作为新数组的指针
    // n 作为全局变量表示a数组的大小, m 作为全局变量表示b数组的大小
    for(int i = n; i < n + m; i ++)
        p[loc ++] = data[i];
    for(int i = 0; i < n; i ++)
        p[loc ++] = data[i];


    for(int i = 0; i < n + m; i ++)
        data[i] = p[i];
}
```

```c++
// 答案使用了更加小的空间复杂度
// 基本的思路是讲原数组逆置，然后再分别讲各自的数组进行再逆转
void change_less(int data[]){
    for(int i = n + m - 1, j = 0; i > (n + m -1) / 2; i --, j ++){
        int t = data[i];
        data[i] = data[j];
        data[j] = t;
    }

    for(int i = 0, j = m - 1; i < m / 2; i ++, j --){
        int t = data[i];
        data[i] = data[j];
        data[j] = t;
    }

    for(int i = m, j = n + m - 1; i < (n + m - 1) / 2; i ++, j --){
        int t = data[i];
        data[i] = data[j];
        data[j] = t;
    }
    
}
```

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304091527745.png)

```c++
// 二分查找
    // find the min value about x location
    int l = 0, r = n - 1;
    while(l < r){
        int mid = l + r + 1 >> 1;
        // 因为我们的目的是找到序列中最后一比x要小于等于数
        // 所以如果当前的值比x的值要小于等于那么我们就要从当前位置往右边找
        // 是否还有数比x数值要小于等于的
        // 否者如果当前的数值已经比我们x数值要大了，由于是一个单调增的序列
        // 所以是我们要找的最后数比x要小的一定是在左侧的
        if(a[mid] <= x) l = mid;
        else r = mid - 1; 
    }

    // swap
    // 特判是否是最后一个数
    if(l == n - 1) return 0;
    else{
        //swap the value
        int t = a[l];
        a[l] = a[l + 1];
        a[l + 1] = t;
    }

    return 0;
```

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304091527429.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304091527912.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304091636777.png)

**设计思想**

1. 首先对数组进行逆转即，从 $[a_0,a_1,...a_p,...,a_n]  \to [a_n,a_{n-1}, ... a_p,a_{p-1}...,a_2,a_1,a_0]$

2. 然后分别对左边区间，数组下标$[0, n - p]$，逆转，同理左区间。

   $[a_p,...,a_n,a_{p-1}...,a_2,a_1,a_0]$ 逆转左区间

   $[a_p,...,a_n,a_0,a_1,a_2,...,a_{p-1}]$ 逆转右区间

```c++
// 对[l,r]区间进行逆置
void Reverse(DataType &a, int l, int r){
    int mid = l + r >> 1;
    for(; l <= mid; l ++, r --){
        int t = a.data[l];
        a.data[l] = a.data[r];
        a.data[r] = t;
    }
}

void exchange(DataType &a, int p){
    int left_size = p, right_size = a.length - p; 
    Reverse(a,0,a.length - 1);
    Reverse(a,0,right_size - 1);
    Reverse(a,right_size, right_size + left_size - 1);
}
```

**可运行代码**

```c++
#include <bits/stdc++.h>
using namespace std;
#define PI 3.14159265359
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head

const int N =  100010;

struct DataType
{
    int data[N];
    int length;
};


// void move_arr(DataType a, int p)
// {
//     int sz = a.length;
//     int left = p - 1, right = 
// }

// 对[l,r]区间进行逆置
void Reverse(DataType &a, int l, int r){
    int mid = l + r >> 1;
    for(; l <= mid; l ++, r --){
        int t = a.data[l];
        a.data[l] = a.data[r];
        a.data[r] = t;
    }
}

void exchange(DataType &a, int p){
    int left_size = p, right_size = a.length - p; 
    Reverse(a,0,a.length - 1);
    Reverse(a,0,right_size - 1);
    Reverse(a,right_size, right_size + left_size - 1);
}


int main()
{
    // init
    DataType a;
    int n = 10;
    for(int i = 0; i < n; i ++)
        a.data[i] = i;
    a.length = 10;

    // output first array
    for(int i = 0; i < n; i ++)
        cout << i << ' ';
    puts(""); 

    for(int i = 0; i < n;i ++)
        cout << a.data[i] << ' ';
    puts("");


    exchange(a,3);

    for(int i = 0; i < n; i ++)
        cout << a.data[i] << ' ';
    puts("");

    return 0;
}
```

**时间复杂度和空间复杂度分析**

$O(n),S(1)$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304091646275.png)

$O(n)的时间复杂度$

```c++
// O(n)
int find(DataType s1[], DataType s2[], int s1_length, int s2_length){
    int t1 = 0, t2 = 0; // t1是s1的指针， t2是s2的指针
    int mid = s1_length + s2_length>> 1; // 中位数的位置
    cout << "mid: " << mid << endl;
    int cnt = 0; // 计数器

    for(;t1 < s1_length, t2 < s2_length;){
        if(s1[t1] <= s2[t2])
        {
            cnt ++;
            if(cnt == mid){
                return s1[t1];
            }
            t1 ++;
        }else{
            cnt ++;
            if(cnt == mid){
                return s2[t2];
            }
            t2 ++;
        }
    }
}
```

答案给的 $O(\log{n})$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304091718724.png)



12.

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304101430825.png)

$O(nlogn)$,但是⚠️这里的unordered_map在408的考试中是不允许出现的。所以只做一个思路展示，在考试中可以手写哈希表，难度也不是很大。

```c++
#include <bits/stdc++.h>
using namespace std;
#define PI 3.14159265359
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 100010;

int a[N], n;
unordered_map<int, int> hs;

int main()
{
    cin >> n;
    rep(i,0,n) cin >> a[i];

    // cout << "test" << endl;
    rep(i,0,n){
        hs[a[i]] ++;
        if(hs[a[i]] > n / 2)
        {
            cout << a[i] << endl;
            return 0;
        }
    }

    puts("-1");

    return 0;
}
```

$O(n)$

算法基本思路

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304101445821.png)

但是这里的本质上就是利用了主元素大于等于的一半的特征

假设我们数组的长度为5

在枚举到的第五位数之前cnt = 0，表示的我们选取的主元素在前四个中出现了两次，有另外两个数与我们选取的主元素的不同。那么这是时候只会出现以下几种情况。

- 前四个中有另外两个与主元素不同的数值**相同**，假设为 $x_0$。假设第五位数出现的是 $x_0$，这是 $x_0$才是主元素。但是如果第五位数不是 $x_0$,是另外的一个新的数，那么我们依然会更换主元素。因为只要第五位不是我们初始的主元素，那么一定意味着，初始的主元素一定不是我们最后要求的主元素。所以最后还需要对我们选取的主元素做一遍验证
- 前四个中有另外两个与主元素不同的数值**不相同**。那么同样的只要第五位数不同于初始化的主元素，那么初始化的主元素一定不是我们要求的主元素。我们更新新的元素同样不会影响什么。
- **也就是第五个元素其实决定了最后主元素是什么。**

```c++
#include <bits/stdc++.h>
using namespace std;
#define PI 3.14159265359
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 100010;

int a[N], n;
unordered_map<int, int> hs;

int main()
{
    cin >> n;
    rep(i,0,n) cin >> a[i];

    int cnt = 1;
    int x = a[0]; // 首先选取的是第一元素作为主元素
    rep(i,1,n){
        if(a[i] == x)
            cnt ++;
        else{
            if(cnt > 0)
                cnt --;
            else{
                x = a[i];
                cnt = 1;
            }
        }
    }

    if(cnt > 0)
    {
        cnt = 0;
        rep(i,0,n)
            if(a[i] == x)
                cnt ++;
    }

    if(cnt > n / 2) cout << x << endl;
    else puts("-1");

    return 0;
}
```

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304101514165.png)

```c++
#include <bits/stdc++.h>
using namespace std;
#define PI 3.14159265359
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 10010;

int a[N], n;

int main()
{
    cin >> n;
    rep(i,0,n) cin >> a[i];

    int minn = INF, maxn = -1;
    rep(i,0,n){
        if(a[i] > 0){
            minn = min(minn,a[i]);
            maxn = max(maxn, a[i]);
        }
    }

    int res = minn - 1;
    bool flag = false;
    if(res > 0) cout << res << endl;
    else{
        bool vis[maxn];
        rep(i, 0, n)
            vis[a[i]] = true;

        rep(i, 1, n + 1)
        {
            flag = vis[i];
            if(!flag) 
            {
                cout << i;
                break;
            }
        }
    }    

    if(flag) puts("-1");
    return 0;
}
```

14.不会

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304101515225.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304101606456.png)

```c++
#include <bits/stdc++.h>
using namespace std;
#define PI 3.14159265359
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=1000000007;
const int INF = 0x3f3f3f3f;
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
const int N = 1010;

int a[N], b[N], c[N];
int n, m, p; // n: len of a; b: len of b ...
int ans; // answer

bool mins(int a, int b, int c){
    return a <= b && a <= c;
}

int abs_(int a){
    if(a >= 0) return a;
    else return -a;
}

int main()
{
    cin >> n;
    rep(i,0,n) cin >> a[i];
    cin >> m;
    rep(i,0,m) cin >> b[i];
    cin >> p; 
    rep(i,0,p) cin >> c[i];


    int i = 0, j = 0, k = 0;
    ans = INF;
    while(i < n && j < m && k < p)
    {
        int d = abs_(a[i] - b[j]) + abs_(b[j] - c[k]) + abs_(c[k] - a[i]);
        ans = min(d, ans);
        if(mins(a[i], b[j], c[k])) i ++;
        else if(mins(b[j], c[k], a[i])) j ++;
        else k ++;
    }

    cout << ans << endl;
    return 0;
}
```

### 2.3.7 链表

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304111712652.png)

```c++
// 采用头插法的方法进行链表的原地逆转 
void reserve(LinkList L){
    LNode *p = L->next;
    LNode *r; // p的后继指针
    L->next = NULL; // 先讲头节点的next置空
    while(p != NULL){
        r = p->next;
        p->next = L->next;
        L->next = p;
        p = r;
    }
    return L;
}
```

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304111713400.png)

```c++
// 使用三个指针，然后将原链表的指针进行反转
void reserve(LinkList L){
    LNode *pre , *p, *r;
    p = L->next, r = p->next;
    if(p == NULL) return L;
    p->next = NULL;
    while(r != NULL){
        pre = p;
        p = r;
        r = r->next;
        p->next = pre;
    }
    L->next = p;
    return L;
} 
```

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304111757501.png)

用空间换时间的方法

```c++
// 若从单链表角度上进行类似的快排，归并等操作都是极其困难的
// 所以在题目没有特别的空间复杂度要求的情况下，我们可以考虑用空间时间
void quick_sort(DataType a[], int l, int r)
{
    int l = 0, r = idx - 1;
    DataType x = a[l + r >> 1];
    int i =  l - 1, j = r + 1;
    while(i < j){
        do i ++; while(a[i] < x);
        do j --; while(a[j] > x);
        if(i < j) swap(a[i], a[j]);
    }

    quick_sort(a, l ,j), quick_sort(a, j + 1, r);
}

void Sort(LinkList L){
    LNode *p = L->next;
    DataType a[L->size];
    int idx = 0;
    while(p != NULL){
        a[idx ++] = p->data;
        p = p->next;
    }

    quick_sort(a,0,idx - 1);
}
```

单链表的快排板子

```c++
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        
        if(head == NULL)    return head;
        Quick_Sort(head, NULL);
        return head;    
    }
    
    void Quick_Sort(ListNode* head, ListNode* end)
    {
        if (head != end && head->next != end)
        {
            ListNode* ptr = head;
            while(ptr->next != end) ptr = ptr->next; // 取链表最后一个元素作为主元
            int pivot = ptr->val;
            
            ListNode* p1 = head;
            ListNode* p2 = head;
            
            while(p2->next != end)
            {
                if(p2->val < pivot)
                {
                    int temp = p2->val;
                    p2->val = p1->val;
                    p1->val = temp;
                    p1 = p1->next;
                }
                p2 = p2->next;
            }
            p2->val = p1->val;
            p1->val = pivot;
            Quick_Sort(head, p1); // 此时 p1 指向 pivot，前一半链表头为 head，尾为 p1
            Quick_Sort(p1->next, end); // 后一半链表头为 p1->next，尾为 end
        }
    }
```

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304121632902.png)

```c++
void del(Linklist L, int minx, int maxx)
{
    LNode *pre = L; // 将头节点赋值到的pre指针上面
    LNode *pt  = pre->next;

    while(pt != NULL){
      	DataType x = pt->data;
        if(x >= minx && x <= maxx)
        {
            LNode *del = pt;
            pre->next = pt->next;
            pt = pt->next;
        }else{
          pr = pt;
          pt = pt->next;
        }
    }
}
```

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304121652520.png)

这里的公共节点的意思**不仅是**存放的数据是相同的。

而是实际上指针应当是指向相同存储在计算机某一块地址上的内存单元

**暴力做法**，找到了直接返回第一个相同的节点。

```c++

LNode find(Linklist L1, Linklist L2)
{
    LNode *p1 = L1->next, *p2 = L2->next;

    while(p1 != NULL){
        LNode *t = p2;
        while(t != NULL)
        {
            if(t == p1)
                return t;
            t = t->next;
        }
        p2 = p2->next;
    }
    return NULL;
}
```

**线性做法**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304121700978.png)

```c++

LNode find(Linklist L1, Linklist L2)
{
    LNode *p1 = L1, *p2 = L2;
    int cnt = 0;
    if(L1.length > L2.length)
    {
        cnt = L1.length - L2.length;
        while(cnt --){
            p1 = p1->next;
        }
    }
    else
    {
        cnt = L2.length - L1.length;
        while(cnt --){
            p2 = p2->next;
        }
    }

    while(p1 != NULL){
        if(p1 == p2)
            return p1;
        else{
            p1 = p1->next;
            p2 = p2->next;
        }
    }

    return NULL; // 返回不存在共同的节点
}
```



# 第三章 栈、队列和数组

## 队列

```c++
struct queue
{   
    int data[N];
    int hh, tt;
};
```

### 队列指针问题

常使用的两种初始化

1. `hh=0, tt=0 `
2. `hh=0,tt=-1`

## 循环队列

### **判断队空和队满的条件**

#### 队空

若以 `1` 的方式进行初始化的话， 队空的条件就是`hh == tt == 0`

若以 `2` 的方式进行初始化的话， 队空的条件就是`tt + 1=hh`

#### 队满

如果不做处理那么队满的条件同队空的条件，所以要进行处理

可以使用三种方式

1. 牺牲一个空间来判断

   这里的本质上就是通过移动一步队尾指针判断移动这一步之后是否就与对头指针重合了。这里说的牺牲一个空间主要也是指的是以 `1`的方式初始化，因为 `1` 的方式初始化队尾指针式指向的是队尾后面的一个位置。

   以`1`条件初始化：

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304031715920.png)

   以 `2`条件初始化：相比于 `1` 的初始化都做一步加一处理

   队空：`(tt + 1)%MaxSize=hh`

   队满：`(tt + 2)%MaxSize == hh`

   队列中的元素个数: `(tt-hh + 1 + MaxSize) % MaxSize`

2. 记录队中的元素个数

   也就是 `size = 0`的情况下是队空，`size = MaxSize`情况下队满

3. 使用tag记录的是上一步的操作是什么

   `tag == 0`表示上一步的操作是删除操作

   `tag == 1`表示上一步的操作是增加操作

   以 `1` 的方式初始化：

   - `if(tag == 0 && hh == tt)  empty`
   - `if(tag == 1 && hh == tt) FULL`
   - `if(hh != tt) size = (tt - hh + MaxSize) % MaxSize // 如果hh==tt的情况下需要进行特判`

   以 `2` 的方式初始化：

   - `if(tag == 0 && hh == tt + 1)  empty`
   - `if(tag == 1 && hh == tt + 1)  FULL`
   - `if(hh != tt) size = (tt - hh + 1 + MaxSize) % MaxSize // 如果hh==tt的情况下需要进行特判`


## 王道第三章大题

### 3.1.5 栈

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304121733953.png)

`Stack[A、B]`

1. C D E B A
2. C D B E A
3. C D B A E

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304121735547.png)

`OUTPUT:B C A E D`

- IN: A B
- OUT: B
- IN: A C
- OUT: C
- OUT: A
- IN: D E
- OUT: E
- OUT: D

`OUTPUT:D B A C E`

- IN: A B C D
- OUT: D
- Not output B  before A

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304121739090.png)

1) A C D (只要在O之前 cnt[O] >= cnt[I])

```c++
bool check(Stack stk){
    int cnt = 0; // 记录在栈内的元素个数
    int sz = stk.size; // 序列长度
    for(int i = 0; i < sz; i ++){
        if(stk.data[i] == 'I')
            cnt ++;
        else{
            // 也就是当前位置为'O'的时候，表示输出
            // 如果在栈里面的元素<0的话那么这个时候还要求元素出栈那么就一定是错误的
            if(cnt <= 0) return false;
            else cnt --;
        }
    }

    return true;
}
```

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304121752421.png)

```c++
bool check(LinkList L){
    char stk[L.length / 2];
    LNode *p = L->next;
    int cnt = L.length / 2;
    int top = -1;
    while(cnt --){
        stk[++ top] = p.data;
        p = p->next;
    }

    // 如果长度是奇数的情况下，还需要再出一个元素
    if(L.length % 2) p = p->next;

    while(p != NULL){
        if(p.data != stk[top]) return false;
        p = p->next;
        top --;
    }
    return true;
}
```

![s](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202304121757266.png)



# 第五章 树与二叉树

## 二叉树的概念



## 线索二叉树以及树的遍历

**总结**

- 先序遍历的后继节点如有左孩子的话，直接后继节点就是其左孩子，如果没有左孩子有右孩子的话那么后继结点就是右孩子。
- 也就是的利用上面这种特性，后序遍历一定是遍历完叶节点在遍历其根节点，所以可以通过后序遍历找到n到m的一条路径。



## 树与二叉树的应用

### 哈夫曼树

对于一组给定的叶节点，它们所构成的哈夫曼树并不一定存在（可以通过补零来解决）或者唯一存在。特别地，（对于度为2的哈夫曼树来说）当叶节点的个数为奇数时，构造哈夫曼树可能存在一些限制。

在上述例子中，如果有四个叶节点，且构造的哈夫曼树的度数为 3，则该哈夫曼树不存在。这是因为，如果每个非叶节点的度数为 $d$，则根据哈夫曼树的性质，该哈夫曼树的总节点数 $n$ 满足：

$$n = 2m - 1,$$

其中 $m$ 是叶节点的个数。又因为每个非叶节点的度数为 $d$，所以非叶节点的个数为 $n-m$，它们的度数之和为 $(n-m)d$。由于在一个图中，节点的度数之和等于边数的两倍，因此我们有：

$$2(n-m) = (n-m)d,$$

即：

$$d = \frac{2}{n-m}.$$

对于四个叶节点的情况，$m=4$，$n=2m-1=7$。将这些值代入上式得到：

$$d = \frac{2}{n-m} = \frac{2}{3},$$

这意味着每个非叶节点的度数必须为 $2/3$，但是这是不可能的，因为度数必须是整数。因此，对于四个叶节点，不存在度数为 3 的哈夫曼树。

需要注意的是，即使存在某个叶节点组合不能构造出符合要求的哈夫曼树，我们仍然可以构造出一棵度数更高的哈夫曼树。这是因为，哈夫曼树不是唯一的，我们可以通过改变节点的位置，构造出不同的哈夫曼树。但是，这些哈夫曼树的深度和路径长度可能不同，因此它们的编码长度也可能不同。

## 树、森林

### 树的存储结构



### 树、森林和二叉树的转换

#### 树转换成二叉树

转换规则：左孩子右兄弟的原则。

如果一个节点有多个孩子的话，左孩子就是其左部分的第一个节点，然后其余的子节点全部串起来，连在左孩子的右孩子节点位位置。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307241600602.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307241600497.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307241600667.png)

#### 森林转换成二叉树

其实的很简单，可以看作每一颗树的根节点的都是兄弟节点（类虚拟结点概念，所有的树都是这个虚拟结点的子节点）。因为每一棵树的根节点一定是只有一个的，所以一定是没有右节点的，所以右子树一定为空，所以每一颗树都仅需要连接到右子树上即可。



# 第六章 图

## 图的基本概念

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305192042682.png)

⚠️

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305192043540.png)

**简单图、多重图**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305192044770.png)

**完全图**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305192044786.png)

**🌟子图**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305192045018.png)

要注意清楚， 极大连通子图和极小连通子图的概念

极大连通子图和极小连通子图的区别如下：

- 极大连通子图是指一个无向图的子图，它是连通的，**并且不能再加入任何一个顶点**而保持连通性。极大连通子图也叫做连通分量，一个无向图可以有多个连通分量，但是一个连通图只有一个极大连通子图，就是它本身。
- 极小连通子图是指一个无向图的子图，它是连通的，并且不能再**删除任何一条边**而保持连通性。极小连通子图也叫做生成树，一个无向图可以有多个生成树，但是一个非连通图没有极小连通子图。
- 总结来说：**极大连通子图是讨论连通分量的,极小连通子图是讨论生成树的**。

**🌟连通、连通图和连通分量**

⚠️这里的概念是无向图来说的

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305192046394.png)

**🌟强连通图、强连通分量**

这是与上面的连通和连通分量的概念相对而言的

**针对是有向图**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305192052308.png)

要清楚的可达 ≠ 两点之间有路径

**🌟生成树、生成森林**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305192054275.png)

## 图的存储

### 邻接矩阵

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305232054095.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305232055541.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305232055037.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305232056150.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305232056435.png)

**⚠️特别注意第六点**

**仅靠上面的特性是远不够的**

**拓展**

1. *简单、连通图*的有向图，如果没有环其邻接矩阵一定是**三角矩阵**

## 总结

- 拓扑图可以是多源点和多汇点的（但一定不能成环）
- 拓扑序唯一不能唯一确定该图长什么样（只能知道其前驱和后继关系）



## 练习

### 6.3.4

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202305202106875.png)

[题解](https://cherish-ls.github.io/2020/09/15/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/)

# 第七章 查找

## 树形查找

### 二叉排序树

二叉树的目的不是为了排序，而是为了提高查找、插入和删除关键字的效率

**定义**（符合以下性质）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071106928.png)

⚠️可以观看第三条性质，可以知道二叉排序中不会存在相同数值的结点。

二叉排序树如果通过**中序遍历**的话就可以得到一个**递增的有序序列**

递归定义，左右子树都是一颗二叉排序树

**查找**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071110368.png)

⚠️要注意的是每次都需要从节点开始查找，在建立BST的过程中很容易会出现建着树建着建着就从新的节点开始建立

**插入**

二叉排序树是一颗**动态树表**

插入是基于查找的基础上进行的，插入比较简单，具体如下。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071115282.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071115698.png)

**构造**

一棵树的构造顺序不同，即使是相同集合元素也可能出现构造的树形不同的情况。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071125317.png)

**⚠️删除**

分别叶节点和中间节点

1. 叶节点直接删除
2. 中间节点
   1. 右子树为空，用左子女填补
   2. 左子树为空，用右子女填补
   3. 左右都不空，那么就在右子树上找中序第一个子女填补，即直接找中序遍历的直接后缀

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071129536.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071129372.png)

**时间复杂度**

主要取决于**树高**

这里有一个平均查找长度的概念

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071136942.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071135138.png)

1. 查找效率 平均$O(\log_2n)$， 最坏 $O(n)$
2. 插入效率 平均$O(\log_2n)$， 最坏 $O(n)$
3. 删除效率 平均$O(\log_2n)$， 最坏 $O(n)$  因为需要先查找后删除所以主要还是取决于查找操作



### 平衡二叉树AVL

**定义**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071155141.png)

**插入**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071155358.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071156612.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071156596.png)

大致上的步骤是：先进行BST的查找，然后再进行调整。

调整的依据是从新插入节点的位置往上找（即沿着父节点找），找到第一个不平衡点，判断是哪种调整的类型，然后进行调整。具体调整类型的方法看上面

**删除**

首先使用BST的删除方式，然后再往上找，进行调整。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071205940.png)

**查找**

同BST

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071208036.png)



**AVL的最高树高与最低树高**

理想树高（最低树高）是满二叉树的情况，$\lceil h = \log_2(n+1)\rceil$

最高树高,AVL的最高树高很难计算，所以如果考到最高树高的时候，一般层数不会太高。要理解下面的思想

**深度与节点个数的极限关系**

这里的下标为N表示层数

$C_N = C_{N-1} + C_{N-2} +1$, 特别的$C_1 = 1$, $C_2 = 2$,这里表示某深度的最小结点数目。

| 层数 | 结点 |
| :--: | :--: |
|  3   |  4   |
|  4   |  7   |
|  5   |  12  |

所以我们知道 $[C_N,C{N+1})$个节点的最大深度是$N$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071153776.png)

20是层数为6的一个分段点，如果节点为22，那么利用 $[C_N,C{N+1})$个节点的最大深度是$N$，知道这里的最大深度为6



### 红黑树

**定义**（性质）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071209210.png)

⚠️

- 要明确什么是叶节点

  叶节点是正常节点往下一层**虚构**的节点，一定是黑色的。一定不能忘记添加业绩点的存在

- 黑高

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071214704.png)

- 结论一

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071214786.png)

  这里也揭示了最长路径与最短路径的性质。

- 结论二

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071215284.png)

  最高树高与最低树高。

**红黑树插入**

红黑树在AVL树的插入调整操作上多进行了一步染色操作

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071416865.png)

判断是否需要调整的操作，首先如果出现两个红节点相邻的情况，那么就一定需要调整。

调整的类型主要的看叔节点的颜色

如果叔节点的颜色为黑色，要进行旋转加染色操作

旋转操作同`AVL`树，区别是在于这里的LL位置判断上的问题，这里的LL指的是新节点位于**爷节点**的LL位置上。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071438669.png)

这里的父换爷的意思是，父亲节点和爷节点进行交换，然后对父节点和爷节点进行交换。

儿换爷：儿节点通过两次旋转换到爷节点上，然后对儿节点和爷节点进行染色。

![RR调整](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071452819.png)

![LR调整](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071454297.png)

![LR左单旋](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071454527.png)

![LR右单旋](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071454653.png)

![LR染色](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071455176.png)

![红叔情况](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071453513.png)

如果叔节点位红色

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071440973.png)

⚠️爷变成新的结点之后就需要递归继续判断是否需要调整

总的来说

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307071440536.png)



## B树和B+树

### B树

特殊的多叉查找树

**定义（性质）**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091643137.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091643276.png)

⚠️⚠️**注意看上面性质的第三条，要求的是非叶节点的子树为 $\lceil \frac{m}{2} \rceil$,而不是关键字为 $\lceil \frac{m}{2} \rceil$**

**无论B树还是B+树都是平衡树，并且是绝对平衡即平衡因子为0**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091643223.png)

- m阶表示的是就是m叉树
- 性质三的引入是为了限制B树的平衡性，使得尽可能使得B树尽可能的矮（这样的话查找效率会更加高，限制非叶节点子树数目为$\lceil\frac{m}{2} \rceil$
- 非叶节点内部排序一定会是有序的并且是升序的
- **叶节点**出现在同一层上，⚠️⚠️注意这里的叶节点要和B+树的叶节点做区分，这里的叶节点是虚构的节点是失败节点，B+树是实际存在的节点

**B树的高度**

⚠️⚠️**不包括不含任何信息的那一层的叶节点**

*最低树高* $h \ge \log_m{(n+1)}$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091655993.png)

*最高树高*  $h \le \log_{\lceil \frac{m}{2} \rceil}(\frac{(n+1)}{2}) + 1$

![=](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091656041.png)

**查找**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091659998.png)

**插入**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091700166.png)

⚠️⚠️要注意的是这里一定是会插入到最底层的终端节点当中的

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091715919.png)

**删除**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091706865.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091707023.png)

删除终端节点

如果删除后节点内关键字不小于 $\lceil \frac{m}{2} \rceil$,直接删除

如果小于的话，分两种情况

1. 左右兄弟如果能借的话![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091724740.png)

   在上面这颗树上删除38节点

   发现右兄弟可以借

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091726516.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091726719.png)

   **本质上就是：当右兄弟很宽裕时，⽤当前结点的后继、后继的后继 来填补空缺**

2. 兄弟不够借

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091727824.png)

   删除49节点

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091727876.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091728070.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091728283.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091728646.png)

   合并之后发现父节点右开始不满足   $\lceil \frac{m}{2} \rceil$性质，开始递归向上做调整

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091729941.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091730031.png)

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091730381.png)

   **在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少⾄0（根结点关键 字个数为1时，有2棵⼦树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关 键字个数减少到 ⌈m/2⌉ − 2，则⼜要与它⾃⼰的兄弟结点进⾏调整或合并操作，并重复上述步骤，直⾄符合B 树的要求为⽌。**

### B+树

B树的内部节点就像一个隔板，分隔出很多的子树。那么B+树就是像分块查找一样，每一个关键值对应这一颗子树。

**定义（性质）**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091733044.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091734766.png)

**叶节点不再是失败节点/虚构节点**

只有叶节点包含信息，其他所有的结点是不包含信息的。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091736313.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307091737515.png)



# 第八章 排序

## 排序的基本概念

**排序的定义**

就是将重新排列表中的所有元素，将元素最后整理成一个有序的序列。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121521440.png)**算法的稳定性**

是否改变原序列的相对位置

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121522515.png)

**外部排序和内部排序**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121522179.png)

## 插入排序

### 直接插入排序

认定为前$i-1$个元素序列都是有序的，将第$i$个元素与前 $i-1$个元素进行对比，插入到前 $i-1$ 个序列当中。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121525695.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121525278.png)

⚠️⚠️注意

- 这里的关键字比较式的从第 $i-1$个元素的开始比较的，一旦找到比关键字小的元素就停下来。

- 在对比关键字计算的时候，不要忘记还有一次同前 $i-1$个元素的最后元素的进行对比

  $21,32,46,40,80,69,90,94$,这里一共比较了9次

  ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121623981.png)

**代码**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121526435.png)

**实例**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121526790.png)

**性能分析**

*空间效率*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121526318.png)

*时间效率*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121527006.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121527205.png)

*稳定性*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121527232.png)

*适用性*

可以用于**链式存储**和顺序存储

### 折半插入

利用前$i-1$个元素是有序的特性，在对比关键字的使用使用了折半查找

**⚠️⚠️注意**

这里的折半查找查找的是相同关键值的最右元素

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121530870.png)

**代码**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121531889.png)

效率上变化不太大，主要区别还是在对比关键字的对比。

那么对于折半查找值适用于顺序存储，所以在 <font color="#dd0000">适用性</font> 上只能使用与 **顺序存储** 结构

### 希尔排序

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121541171.png)

**基本思想**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121541413.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121542529.png)

**实例**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121542145.png)

**代码**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121542971.png)

**性能分析**

*空间效率*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121543426.png)

*时间效率*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121543073.png)

*稳定性*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307121543149.png)

*实用性*

仅使用于**顺序存储**

## 交换排序

### 冒泡排序

**基本思想**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307131630570.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307131630540.png)

**实例**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307131631519.png)

**代码**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307131631100.png)

这里有个特性，如果一趟排序之后没有发生任何的交换，就说明表已经有序了。那么就可以提前中断。

**性能分析**

*空间效率*：在交换的时候使用了一个辅助单元 $O(1)$

*时间效率*：$O(n^2)$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307131638072.png)

这段话说的移动次数的计算不太明白

*稳定性*： 稳定

*适用性：* 可以适用在顺序存储结构和<font color="#dd0000">链表</font>存储结构当中

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307131639034.png)

### 快速排序

**基本思想**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101652160.png)

**实例**

一趟排序

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307131641864.png)

注意上看上面的红字。

**算法（代码）**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101700783.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101701496.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101701089.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101701251.png)

以子序列的第一个元素的为基准

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101701845.png)

因为low这里为空了，所以第一步只能执行high指针的操作先

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101702071.png)

high找到第一个比基准要严格小的元素位置，就将27交换到low指向的位置当中

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101703998.png)

然后如果`low != high`移动low指针，找到第一个比基准要大的元素位置

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101704962.png)

交换位置到`high`指针指向的位置

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101705401.png)

再不断循环high指针和low指针的操作

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101706269.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101706291.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101706184.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101707789.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101707390.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101707102.png)

现在low == high 那么就表示第一个划分已经完成，注意上面一个partition的操作，并不是一趟的排序。

然后以划分点low指向的位置，分为左右再依次划分下去，重复上面的操作，直到子序列中元素只有一个即无法再划分的时候结束。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101709603.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101709761.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101710961.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101710283.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101710986.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101710335.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101710518.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101710832.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101710245.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101711799.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101711547.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101711010.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101711903.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101712581.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101712313.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101712878.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101712979.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101712802.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101713448.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101713498.png)

**时间和空间复杂度计算**

**空间效率**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101714724.png)

**时间复杂度**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101715010.png)

实际上我们可以知道无论时间复杂度还是空间复杂都与递归的层数有关

时间复杂度来说 = $O(n*递归层数)$

空间复杂度 = $O(递归层数)$

递归层数可以化二叉树进行判断，二叉树高 = 递归层数

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101718284.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307101718749.png)

最坏的情况是已经有序的情况，比如 $\{1,2,3,4,5,6,7\}$

很容易想到最后出来二叉树一定是一颗单枝二叉树，树高为7

**稳定性**

不稳定算法,ps. {3,2,2}

⚠️⚠️注意的一个概念

![截屏2023-07-13 17.20.14](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307131720021.png)

## 选择排序

### 简单选择排序

通过对子表的一次次比较关键字，最后找出该趟的最小元素，然后放在子表中的第一个元素的位置。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141634804.png)

**代码**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141636209.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141636227.png)

**性能分析**

*空间效率* ：$O(1)$

*时间效率*：$O(n^2)$

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141638913.png)

*稳定性：* <font color="#dd0000">不稳定</font>

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141638995.png)

### 堆排序

**定义**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141639659.png)

以大根堆为例：

我们可以从上面看到，定义说的是根节点的值大于等于两个子节点的值。那如果只有一个孩子并且孩子的值等于父节点的值，是否可以随意放在左右两个孩子节点当中呢？其实不是的，我们最好还是要符合完全二叉树的性质，所以尽量还是放在左孩子位置上。

**[基本思想](https://www.icourse163.org/learn/kaopei-1467196161?tid=1468320445#/learn/content?type=detail&id=1254286466&cid=1285498079)**

建堆然后堆顶元素出堆

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141646708.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141647365.png)

首先是将原序列按照完成二叉树形式，摆上树上节点处。然后从最后一个非叶节点 $编号i \le \lfloor \frac{n}{2} \rfloor$ 的开始调整。假如这里是大根堆，如果父节点比孩子节点中最大的节点要小的话，那么与最大的孩子节点进行交换，注意⚠️⚠️与孩子节点交换完之后可能孩子节点这个位置也会发现不满足大根堆性质，继续递归下去进行处理。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141657247.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141657274.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141657287.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141657294.png)

建立好堆之后就可以进行堆排序了。堆排序也就是将堆顶元素出堆，然后将树上的最后一个元素进行替换，然后进行小元素下坠。

**建立大根堆代码**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141652358.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141653271.png)

*调整的时间复杂度* ：$O(h)$

<font color="#dd0000">注意建堆是时间复杂度是O(n)而不是O(logn)</font>

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141655023.png)

**堆排序算法**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141653638.png)

**性能分析**

*空间复杂度：* $O(1)$

*时间复杂度:* $O(n\log_2n)$(最好最快平均）

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141659381.png)

建堆的时间复杂度 

*稳定性：* 不稳定

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141700847.png)

**插入与删除操作**

[*插入*](https://www.icourse163.org/learn/kaopei-1467196161?tid=1468320445#/learn/content?type=detail&id=1254286466&cid=1285475484)

⚠️⚠️注意插入的不是想之前需要查找一次，然后插入到相应的位置，而是插入到完全二叉树的最后一个位置上。

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141703965.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307141703026.png)

之后的调整就不再赘述，看上图的注解。

注意的是插入<font color="#dd0000">不需要把换下来的元素与下面的节点继续比较下去</font>

[*删除*](https://www.icourse163.org/learn/kaopei-1467196161?tid=1468320445#/learn/content?type=detail&id=1254286466&cid=1285475484)

删除是将最后一个元素替代删除的节点，然后使用小元素下坠的方法进行调整。

具体内容可以点击下划线的内容。

**拓展与总结**

1. 相同元素不同的元素排列情况，堆一定相同
2. 堆排序因为序列元素相同，即使不同的排列顺序，最后的建立的堆都是一样，所以最后的堆排序，调整都是相同的。不被初始序列状态影响。所以堆排序过程的比较次数与初始状态无关。

## 归并排序和基数排序

### [归并排序](https://www.icourse163.org/learn/kaopei-1467196161?tid=1468320445#/learn/content?type=detail&id=1254291605&cid=1285496284)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221542805.png)

可以发现归并排序的对比关键字次数也是固定的，对比关键字次数为  归并次数 * $\frac{n}{2}$，每一趟对比 $\frac{n}{2}$

注意一个概念什么是n路归并算法。

n路算法其实就是每次归并时候归并多少个子序列。

**性能分析**

*空间效率：* $O(n)$

*时间效率：*$O(n\log_2n)$

稳定性：稳定

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221556026.png)

### [基数排序](https://www.icourse163.org/learn/kaopei-1467196161?tid=1468320445#/learn/content?type=detail&id=1254291605&cid=1285462994)

**基数排序的原理与定义（理解这里的思想）**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221557613.png)

**实现**

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221559578.png)

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221559298.png)

这里的例子是以`LSD`算法为例

有几个注意点：

1. LSD是从$0$到$r$的顺序开始收集的

2. 每个$q[i]$同一个头指针一样，所以在收集的时候顺序一定不能乱，是从头指针开始，如上面的第三趟分配之后，收集 $q[0]$是从 $008 \to 063\to083$的方向收集的，在不同链表之间的收集也是如此，比如收集完 $q[0]$的单链表之后我们还需要收集 $q[1]$的单链表，接在 $083$ 元素之后就是 $019$元素

3. 每个链表内部都是采用的是<span style='color:#CE3C05'>尾插法</span>，即新加入同一个链表内的是插入到最后一个元素当中。

4. MSD与LSD相反，即位数的排列是逆序的，收集也就是从高位开始收集，但依然链表内部采用的是尾插法，依然是从个位开始分配

   ![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221606836.png)

**性能分析**

*空间效率：*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221626061.png)

*时间效率：*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221627631.png)

*稳定性：*

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221627995.png)



## 总结

![](https://124newblog-1309411887.cos.ap-nanjing.myqcloud.com/images/202307221635714.png)

1. 有些排序算法在每一趟排序过程中，都会有一个元素放到最终位置上

   堆排序，每次堆顶元素都是最大（小）值

   冒泡排序，每次都将最值放到冒到子序列中的最前面

   <font color="#dd0000">快排</font>，每趟都随机选一个值，然后将其放到正确位置上

2. 有些排序算法在每一趟排序过程中，都会有一个元素放到最终位置上，那么有些排序算法就不能实现这一个特性

   希尔排序，从客观上来说算法实现角度上，希尔排序并没有真正实现每次排序都将元素放到正确的位置上。可能凑巧实现，比如有序的时候。

   归并排序

3. 排序过程的比较次数与初始状态无关的算法

   归并排序

   选择排序，选择排序包括了简单选择排序和堆排序。主要将一下为什么堆排序的比较次数与初始状态无关。

   堆排序因为序列元素相同，即使不同的排列顺序，最后的建立的堆都是一样，所以最后的堆排序，调整都是相同的。不被初始序列状态影响。所以堆排序过程的比较次数与初始状态无关。

   

# 总结

## 名词解释

### 图

DAG：有向无环图（要会对表达式建立一棵树）

AOV：在DAG基础之上，顶点表示活动（具有先后关系的一系列活动）

AOE：在DAG基础上，带权值的图。顶点表示时间，有向边表示活动的图。（AOE的算法要注意）

## 算法总结

### 图的算法

**最小生成树（两个算法）**

Prim算法是选点

Kruskal算法是选边

**最短路径（两个算法）**

Dijkstra算法不适用于带有负权值的边的图（也就是说可以用于存在环的图）

FLoyd算法不适用于包含负权值的边组成的回路，但是允许图中存在负权值

















