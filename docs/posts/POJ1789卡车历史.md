---
title: POJ1789 卡车历史
date: 2022-07-14 20:21:01
tags:
- 图论
- 最小生成树
categories: 
- - 图论
---

## [卡车历史](https://www.acwing.com/problem/content/4335/)

有 N 个点，每个点用一个长度为 7 的由小写字母构成的字符串表示。
不同点对应的字符串不同。
对于任意两点，它们对应的字符串在多少个位置上字母不同，则它们之间的距离就是多少。
例如，aaaa 和 baba 在第 1,3 个位置上字母不同，则它们之间的距离为 2。
现在，要将这 N 个点用边连接，组成一个树，要求组成树的所有边长之和尽可能小。
请你计算并输出最小边长和。

输入格式
输入包含多组测试数据。
每组数据第一行包含整数 N。
接下来 N 行，每行包含一个长度为 7 的由小写字母构成的字符串，表示一个点。
当输入 N=0 时，表示输入结束。

输出格式
输出一行，格式为 The highest possible quality is 1/Q.，其中 Q 为最小边长和。

数据范围
每组输入最多包含 10 组数据。
2≤N≤2000,
每个输入的所有 N 之和不超过 2000。

输入样例：
```
4
aaaaaaa
baaaaaa
abaaaaa
aabaaaa
0
```
输出样例：
```
The highest possible quality is 1/3.
```

### 思路
**本题难点在于看出这是一个最小生成树问题，并对本题进行建图**
本题要求的是最小变换次数，一次只能改变一个位置的字符串
分析样例
aaaaaaa 
* 与 baaaaaa 只需变换第一位a变为b，一次变换
* 与 abaaaaa 只需变换第二位a变为b，一次变换
* 与 aabaaaa 只需变换第三位a变为b，一次变换

baaaaaa
* abaaaaa 变换第一位b变为a，第二位a变为b，两次变换
* aabaaaa 变换第一位b变为a，变换第三a变为b，两次变换
  
abaaaaa
* aabaaaa 第二位b变为a，第三位a变为b，两次变换

比如 aaaaaaa变换到baaaaaa  相当于aaaaaaa这个节点与baaaaaa连一条边，这个边的边权等于它们之间变换的次数
这样子就可以建立起一张完全图。要想所有的节点都变为相同的字符串，那么必然需要将其所有节点连通，并且最后一定是生成一棵树。

证明： 为什么一定会生成一棵树呢？？因为我们的所有边权都是正值，一定是没有负权边的，所以一共n个节点，其连通为连通图的最小边数为n-1条边就是一颗树的情况，每多加一条边，那么权值之和一定会增加。所以我们就将上面问题转换为一个最小生成树问题。

完全图：边数m = n*(n-1),所以在这里使用Prim算法会更优

### CODE
```c
#include <vector>
#include <cstring>
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <map>

#define LL long long
#define pii pair<int,int>
#define x first
#define y second

using namespace std;

const int INF = 0x3f3f3f3f, N = 2010;

int n;
int mp[N][N];
int dis[N];
bool st[N];
char s[N][7];

void build()
{
    for(int i = 1; i <= n; i ++)
        for(int j = i + 1; j <= n; j ++)
        {
            int cnt = 0;
            for(int k = 0; k < 7; k ++)
                if(s[i][k] != s[j][k]) cnt ++;
            mp[i][j] = mp[j][i] = cnt;
        }
}

int prim()
{
    memset(dis, 0x3f, sizeof dis);
    memset(st, false, sizeof st);
    int res = 0;
    for(int i = 0; i < n; i ++)
    {
        int t = -1;
        for(int j = 1; j <= n; j ++)
            if(!st[j] && (t == -1 || dis[j] < dis[t])) t = j;

        if(i && dis[t] == INF) return INF;
        st[t] = true;
        if(i) res += dis[t];

        for(int j = 1; j <= n; j ++) dis[j] = min(dis[j],mp[t][j]);
    }
    return res;
}

int main()
{
    while(scanf("%d",&n), n)
    {
        memset(mp,0x3f,sizeof mp);
        for(int i = 1; i <= n; i ++)
            for(int j = 0; j < 7; j ++)
                cin >> s[i][j];

        build();
        int ans = prim();
        cout << "The highest possible quality is 1/" << ans << "." << endl;
    }
    return 0;
}
```